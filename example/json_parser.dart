// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

library json_parser;

class _KeyValuePair<K, V> {
  final K key;
  final V value;
  const _KeyValuePair(this.key, this.value);
  String toString() => "$key : $value";
}

String _hex2str(String hex) {
  return new String.fromCharCode(int.parse(hex, radix: 16));
}

String _escape(String string) {
  switch (string) {
    case "\"":
      return "\u0022";
    case "\\":
      return "\u005c";
    case "/":
      return "\u002f";    
    case "r":
      return "\u000d";
    case "n":
      return "\u000a";  
    case "t":
      return "\u0009";
    case "b":
      return "\u0008";
    case "f":
      return "\u000c";      
  }
  return string;
}
class JsonParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["\'\"\'", "\'[\'", "\'false\'", "\'null\'", "\'true\'", "\'{\'", "NUMBER"];
  
  static final List<String> _expect1 = <String>["\'{\'"];
  
  static final List<String> _expect10 = <String>["\'null\'"];
  
  static final List<String> _expect11 = <String>["NUMBER"];
  
  static final List<String> _expect12 = <String>["\'true\'"];
  
  static final List<String> _expect13 = <String>["WS"];
  
  static final List<String> _expect14 = <String>["CHAR"];
  
  static final List<String> _expect15 = <String>["CHAR_HEXDIG"];
  
  static final List<String> _expect16 = <String>["\'.\'"];
  
  static final List<String> _expect17 = <String>["DIGIT"];
  
  static final List<String> _expect18 = <String>["\'\\\'"];
  
  static final List<String> _expect19 = <String>["EXP"];
  
  static final List<String> _expect2 = <String>["\'\"\'"];
  
  static final List<String> _expect20 = <String>["E", "e"];
  
  static final List<String> _expect21 = <String>["+", "-"];
  
  static final List<String> _expect22 = <String>["HEXDIG"];
  
  static final List<String> _expect23 = <String>["INT"];
  
  static final List<String> _expect24 = <String>["NUMBER_PART"];
  
  static final List<String> _expect25 = <String>["STRING_CHARS"];
  
  static final List<String> _expect26 = <String>["UNESCAPED"];
  
  static final List<String> _expect3 = <String>["\',\'"];
  
  static final List<String> _expect4 = <String>["\'[\'"];
  
  static final List<String> _expect5 = <String>["\']\'"];
  
  static final List<String> _expect6 = <String>["\'}\'"];
  
  static final List<String> _expect7 = <String>["EOF"];
  
  static final List<String> _expect8 = <String>["\'false\'"];
  
  static final List<String> _expect9 = <String>["\':\'"];
  
  static final List<bool> _lookahead = _unmap([0xffc801, 0x4000000, 0x78104040, 0xfc07f, 0x3f8000, 0x400000]);
  
  // '\t', '\n', '\r', ' '
  static final List<bool> _mapping0 = _unmap([0x800013]);
  
  // '\"', '/', '\\', 'b', 'f', 'n', 'r', 't'
  static final List<bool> _mapping1 = _unmap([0x2001, 0x8000000, 0x144044]);
  
  // 'false'
  static final List<int> _strings0 = <int>[102, 97, 108, 115, 101];
  
  // 'null'
  static final List<int> _strings1 = <int>[110, 117, 108, 108];
  
  // 'true'
  static final List<int> _strings2 = <int>[116, 114, 117, 101];
  
  final List<int> _tokenFlags = [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0];
  
  final List<String> _tokenNames = ["WS", "CHAR", "CHAR_HEXDIG", "\'.\'", "DIGIT", "\'\\\'", "EXP", "\'.\'", "HEXDIG", "INT", "NUMBER_PART", "\'\"\'", "STRING_CHARS", "UNESCAPED"];
  
  static final List<List<int>> _transitions0 = [[34, 34], [45, 45, 48, 57], [91, 91], [102, 102], [110, 110], [116, 116], [123, 123]];
  
  static final List<List<int>> _transitions1 = [[34, 34, 45, 45, 48, 57, 91, 91, 102, 102, 110, 110, 116, 116, 123, 123]];
  
  static final List<List<int>> _transitions2 = [[45, 45, 48, 57]];
  
  static final List<List<int>> _transitions3 = [[32, 33, 35, 91, 93, 1114111], [92, 92]];
  
  static final List<List<int>> _transitions4 = [[48, 57, 65, 70, 97, 102]];
  
  static final List<List<int>> _transitions5 = [[69, 69, 101, 101]];
  
  static final List<List<int>> _transitions6 = [[69, 69], [101, 101]];
  
  static final List<List<int>> _transitions7 = [[43, 43], [45, 45]];
  
  static final List<List<int>> _transitions8 = [[48, 57], [65, 70], [97, 102]];
  
  static final List<List<int>> _transitions9 = [[32, 33], [35, 91], [93, 126], [127, 1114111]];
  
  List _cache;
  
  int _cachePos;
  
  List<int> _cacheRule;
  
  List<int> _cacheState;
  
  int _ch;
  
  int _cursor;
  
  List<JsonParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenLevel;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  JsonParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;
    if (_inputLen >= 0x3fffffe8 / 32) {
      throw new StateError('File size to big: $_inputLen');
    }  
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {  
    var cached = _cache[start];
    if (cached == null) {
      _cacheRule[start] = id;
      _cache[start] = [result, _cursor, success];
    } else {    
      var slot = start >> 5;
      var r1 = (slot << 5) & 0x3fffffff;    
      var mask = 1 << (start - r1);    
      if ((_cacheState[slot] & mask) == 0) {
        _cacheState[slot] |= mask;   
        cached = [new List.filled(3, 0), new Map<int, List>()];
        _cache[start] = cached;                                      
      }
      slot = id >> 5;
      r1 = (slot << 5) & 0x3fffffff;    
      mask = 1 << (id - r1);    
      cached[0][slot] |= mask;
      cached[1][id] = [result, _cursor, success];      
    }
    if (_cachePos < start) {
      _cachePos = start;
    }    
  }
  
  void _beginToken(int tokenId) {
    if (_tokenLevel++ == 0) {
      _token = tokenId;
      _tokenStart = _cursor;
    }  
  }
  
  void _endToken() {
    if (--_tokenLevel == 0) {
      _token = null;
      _tokenStart = null;
    }    
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated $name";
        _errors.add(new JsonParserError(JsonParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed $name";
        _errors.add(new JsonParserError(JsonParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(name);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    var result = _cache[_cursor];
    if (result == null) {
      return null;
    }    
    var slot = _cursor >> 5;
    var r1 = (slot << 5) & 0x3fffffff;  
    var mask = 1 << (_cursor - r1);
    if ((_cacheState[slot] & mask) == 0) {
      if (_cacheRule[_cursor] == id) {      
        _cursor = result[1];
        success = result[2];      
        if (_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      } else {
        return null;
      }    
    }
    slot = id >> 5;
    r1 = (slot << 5) & 0x3fffffff;  
    mask = 1 << (id - r1);
    if ((result[0][slot] & mask) == 0) {
      return null;
    }
    var data = result[1][id];  
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }   
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_BEGIN_ARRAY() {
    // LEXEME
    // BEGIN_ARRAY <- '[' WS
    var $$;
    // => '[' WS # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => '[' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '['
          $$ = '[';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '['
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '[' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect4);
    }
    // <= '[' WS # Choice
    return $$;
  }
  
  dynamic _parse_BEGIN_OBJECT() {
    // LEXEME
    // BEGIN_OBJECT <- '{' WS
    var $$;
    // => '{' WS # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect1);
    }
    // <= '{' WS # Choice
    return $$;
  }
  
  dynamic _parse_CHAR() {
    // MORPHEME
    // CHAR <- UNESCAPED / ESCAPE ["/\\bfnrt] / ESCAPE 'u' CHAR_HEXDIG
    var $$;
    _beginToken(1);  
    // => UNESCAPED / ESCAPE ["/\\bfnrt] / ESCAPE 'u' CHAR_HEXDIG # Choice
    switch (_getState(_transitions3)) {
      // [ -!] [#-[] []-\u0010ffff]
      case 0:
        var startPos0 = _startPos;
        // => UNESCAPED
        $$ = _parse_UNESCAPED();
        // <= UNESCAPED
        _startPos = startPos0;
        break;
      // [\\]
      case 1:
        while (true) {
          // => ESCAPE ["/\\bfnrt] # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ESCAPE
            $$ = _parse_ESCAPE();
            // <= ESCAPE
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => ["/\\bfnrt]
            $$ = _matchMapping(34, 116, _mapping1);
            // <= ["/\\bfnrt]
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // ESCAPE
              final $1 = seq[0];
              // ["/\\bfnrt]
              final $2 = seq[1];
              $$ = _escape($2);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= ESCAPE ["/\\bfnrt] # Sequence
          if (success) break;
          // => ESCAPE 'u' CHAR_HEXDIG # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => ESCAPE
            $$ = _parse_ESCAPE();
            // <= ESCAPE
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => 'u'
            $$ = _matchChar(117, 'u');
            // <= 'u'
            if (!success) break;
            seq[1] = $$;
            // => CHAR_HEXDIG
            $$ = _parse_CHAR_HEXDIG();
            // <= CHAR_HEXDIG
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // ESCAPE
              final $1 = seq[0];
              // 'u'
              final $2 = seq[1];
              // CHAR_HEXDIG
              final $3 = seq[2];
              $$ = _hex2str($3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos2;
          // <= ESCAPE 'u' CHAR_HEXDIG # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: CHAR
      _failure(_expect14);
    }
    // <= UNESCAPED / ESCAPE ["/\\bfnrt] / ESCAPE 'u' CHAR_HEXDIG # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_CHAR_HEXDIG() {
    // MORPHEME
    // CHAR_HEXDIG <- HEXDIG HEXDIG HEXDIG HEXDIG
    var $$;
    _beginToken(2);  
    // => HEXDIG HEXDIG HEXDIG HEXDIG # Choice
    switch (_getState(_transitions4)) {
      // [0-9] [A-F] [a-f]
      case 0:
        // => HEXDIG HEXDIG HEXDIG HEXDIG # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => HEXDIG
          $$ = _parse_HEXDIG();
          // <= HEXDIG
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => HEXDIG
          $$ = _parse_HEXDIG();
          // <= HEXDIG
          if (!success) break;
          seq[1] = $$;
          // => HEXDIG
          $$ = _parse_HEXDIG();
          // <= HEXDIG
          if (!success) break;
          seq[2] = $$;
          // => HEXDIG
          $$ = _parse_HEXDIG();
          // <= HEXDIG
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // HEXDIG
            final $1 = seq[0];
            // HEXDIG
            final $2 = seq[1];
            // HEXDIG
            final $3 = seq[2];
            // HEXDIG
            final $4 = seq[3];
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= HEXDIG HEXDIG HEXDIG HEXDIG # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: CHAR_HEXDIG
      _failure(_expect15);
    }
    // <= HEXDIG HEXDIG HEXDIG HEXDIG # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_DECIMAL_POINT() {
    // MORPHEME
    // DECIMAL_POINT <- '.' WS
    var $$;
    _beginToken(3);  
    // => '.' WS # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => '.' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '.'
          $$ = '.';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '.'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '.'
            final $1 = seq[0];
            // WS
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '.' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '.'
      _failure(_expect16);
    }
    // <= '.' WS # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_DIGIT() {
    // MORPHEME
    // DIGIT <- [0-9]
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(23);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(4);    
    // => [0-9] # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: DIGIT
      _failure(_expect17);
    }
    // <= [0-9] # Choice
    _addToCache($$, pos, 23);
    _endToken();
    return $$;
  }
  
  dynamic _parse_END_ARRAY() {
    // LEXEME
    // END_ARRAY <- ']' WS
    var $$;
    // => ']' WS # Choice
    switch (_ch == 93 ? 0 : _ch == -1 ? 2 : 1) {
      // []]
      case 0:
        // => ']' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ']'
          $$ = ']';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ']'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ']' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ']'
      _failure(_expect5);
    }
    // <= ']' WS # Choice
    return $$;
  }
  
  dynamic _parse_END_OBJECT() {
    // LEXEME
    // END_OBJECT <- '}' WS
    var $$;
    // => '}' WS # Choice
    switch (_ch == 125 ? 0 : _ch == -1 ? 2 : 1) {
      // [}]
      case 0:
        // => '}' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '}'
          $$ = '}';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '}'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '}' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '}'
      _failure(_expect6);
    }
    // <= '}' WS # Choice
    return $$;
  }
  
  dynamic _parse_EOF() {
    // LEXEME
    // EOF <- !.
    var $$;
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect7);
    }
    // <= !. # Choice
    return $$;
  }
  
  dynamic _parse_ESCAPE() {
    // MORPHEME
    // ESCAPE <- '\\'
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(24);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(5);    
    // => '\\' # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        var startPos0 = _startPos;
        // => '\\'
        $$ = '\\';
        success = true;
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }
        // <= '\\'
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '\'
      _failure(_expect18);
    }
    // <= '\\' # Choice
    _addToCache($$, pos, 24);
    _endToken();
    return $$;
  }
  
  dynamic _parse_EXP() {
    // MORPHEME
    // EXP <- ('e' / 'E') ('-' / '+')? DIGIT+
    var $$;
    _beginToken(6);  
    // => ('e' / 'E') ('-' / '+')? DIGIT+ # Choice
    switch (_getState(_transitions5)) {
      // [E] [e]
      case 0:
        // => ('e' / 'E') ('-' / '+')? DIGIT+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ('e' / 'E') # Choice
          switch (_getState(_transitions6)) {
            // [E]
            case 0:
              var startPos1 = _startPos;
              // => 'E'
              $$ = 'E';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= 'E'
              _startPos = startPos1;
              break;
            // [e]
            case 1:
              var startPos2 = _startPos;
              // => 'e'
              $$ = 'e';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= 'e'
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: e, E
            _failure(_expect20);
          }
          // <= ('e' / 'E') # Choice
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => ('-' / '+')?
          var testing0 = _testing;
          _testing = _cursor;
          // => ('-' / '+') # Choice
          switch (_getState(_transitions7)) {
            // [+]
            case 0:
              var startPos3 = _startPos;
              // => '+'
              $$ = '+';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= '+'
              _startPos = startPos3;
              break;
            // [-]
            case 1:
              var startPos4 = _startPos;
              // => '-'
              $$ = '-';
              success = true;
              if (++_cursor < _inputLen) {
                _ch = _input[_cursor];
              } else {
                _ch = -1;
              }
              // <= '-'
              _startPos = startPos4;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: -, +
            _failure(_expect21);
          }
          // <= ('-' / '+') # Choice
          success = true; 
          _testing = testing0;
          // <= ('-' / '+')?
          if (!success) break;
          seq[1] = $$;
          // => DIGIT+
          var testing1;
          for (var first = true, reps; ;) {  
            // => DIGIT  
            $$ = _parse_DIGIT();  
            // <= DIGIT  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing1 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing1;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= DIGIT+
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ('e' / 'E') ('-' / '+')? DIGIT+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EXP
      _failure(_expect19);
    }
    // <= ('e' / 'E') ('-' / '+')? DIGIT+ # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_FALSE() {
    // LEXEME
    // FALSE <- 'false' WS
    var $$;
    // => 'false' WS # Choice
    switch (_ch == 102 ? 0 : _ch == -1 ? 2 : 1) {
      // [f]
      case 0:
        // => 'false' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'false'
          $$ = _matchString(_strings0, 'false');
          // <= 'false'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'false'
            final $1 = seq[0];
            // WS
            final $2 = seq[1];
            $$ = false;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'false' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'false'
      _failure(_expect8);
    }
    // <= 'false' WS # Choice
    return $$;
  }
  
  dynamic _parse_FRAC() {
    // MORPHEME
    // FRAC <- DECIMAL_POINT DIGIT+
    var $$;
    _beginToken(7);  
    // => DECIMAL_POINT DIGIT+ # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => DECIMAL_POINT DIGIT+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => DECIMAL_POINT
          $$ = _parse_DECIMAL_POINT();
          // <= DECIMAL_POINT
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => DIGIT+
          var testing0;
          for (var first = true, reps; ;) {  
            // => DIGIT  
            $$ = _parse_DIGIT();  
            // <= DIGIT  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= DIGIT+
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= DECIMAL_POINT DIGIT+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '.'
      _failure(_expect16);
    }
    // <= DECIMAL_POINT DIGIT+ # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_HEXDIG() {
    // MORPHEME
    // HEXDIG <- DIGIT / [a-f] / [A-F]
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(27);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(8);    
    // => DIGIT / [a-f] / [A-F] # Choice
    switch (_getState(_transitions8)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => DIGIT
        $$ = _parse_DIGIT();
        // <= DIGIT
        _startPos = startPos0;
        break;
      // [A-F]
      case 1:
        var startPos1 = _startPos;
        // => [A-F]
        $$ = _matchRange(65, 70);
        // <= [A-F]
        _startPos = startPos1;
        break;
      // [a-f]
      case 2:
        var startPos2 = _startPos;
        // => [a-f]
        $$ = _matchRange(97, 102);
        // <= [a-f]
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEXDIG
      _failure(_expect22);
    }
    // <= DIGIT / [a-f] / [A-F] # Choice
    _addToCache($$, pos, 27);
    _endToken();
    return $$;
  }
  
  dynamic _parse_INT() {
    // MORPHEME
    // INT <- DIGIT+
    var $$;
    _beginToken(9);  
    // => DIGIT+ # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => DIGIT+
        var testing0;
        for (var first = true, reps; ;) {  
          // => DIGIT  
          $$ = _parse_DIGIT();  
          // <= DIGIT  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= DIGIT+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: INT
      _failure(_expect23);
    }
    // <= DIGIT+ # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_NAME_SEPARATOR() {
    // LEXEME
    // NAME_SEPARATOR <- ':' WS
    var $$;
    // => ':' WS # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ':'
      _failure(_expect9);
    }
    // <= ':' WS # Choice
    return $$;
  }
  
  dynamic _parse_NULL() {
    // LEXEME
    // NULL <- 'null' WS
    var $$;
    // => 'null' WS # Choice
    switch (_ch == 110 ? 0 : _ch == -1 ? 2 : 1) {
      // [n]
      case 0:
        // => 'null' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'null'
          $$ = _matchString(_strings1, 'null');
          // <= 'null'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'null'
            final $1 = seq[0];
            // WS
            final $2 = seq[1];
            $$ = null;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'null' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'null'
      _failure(_expect10);
    }
    // <= 'null' WS # Choice
    return $$;
  }
  
  dynamic _parse_NUMBER() {
    // LEXEME
    // NUMBER <- NUMBER_PART WS
    var $$;
    // => NUMBER_PART WS # Choice
    switch (_getState(_transitions2)) {
      // [-] [0-9]
      case 0:
        // => NUMBER_PART WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => NUMBER_PART
          $$ = _parse_NUMBER_PART();
          // <= NUMBER_PART
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // NUMBER_PART
            final $1 = seq[0];
            // WS
            final $2 = seq[1];
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= NUMBER_PART WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NUMBER
      _failure(_expect11);
    }
    // <= NUMBER_PART WS # Choice
    return $$;
  }
  
  dynamic _parse_NUMBER_PART() {
    // MORPHEME
    // NUMBER_PART <- '-'? INT FRAC? EXP?
    var $$;
    _beginToken(10);  
    // => '-'? INT FRAC? EXP? # Choice
    switch (_getState(_transitions2)) {
      // [-] [0-9]
      case 0:
        // => '-'? INT FRAC? EXP? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '-'?
          var testing0 = _testing;
          _testing = _cursor;
          // => '-'
          $$ = _matchChar(45, '-');
          // <= '-'
          success = true; 
          _testing = testing0;
          // <= '-'?
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => INT
          $$ = _parse_INT();
          // <= INT
          if (!success) break;
          seq[1] = $$;
          // => FRAC?
          var testing1 = _testing;
          _testing = _cursor;
          // => FRAC
          $$ = _parse_FRAC();
          // <= FRAC
          success = true; 
          _testing = testing1;
          // <= FRAC?
          if (!success) break;
          seq[2] = $$;
          // => EXP?
          var testing2 = _testing;
          _testing = _cursor;
          // => EXP
          $$ = _parse_EXP();
          // <= EXP
          success = true; 
          _testing = testing2;
          // <= EXP?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '-'?
            final $1 = seq[0];
            // INT
            final $2 = seq[1];
            // FRAC?
            final $3 = seq[2];
            // EXP?
            final $4 = seq[3];
            $$ = double.parse(_text());
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '-'? INT FRAC? EXP? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: NUMBER_PART
      _failure(_expect24);
    }
    // <= '-'? INT FRAC? EXP? # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_QUOTATION_MARK() {
    // MORPHEME
    // QUOTATION_MARK <- '"'
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(30);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(11);    
    // => '"' # Choice
    switch (_ch == 34 ? 0 : _ch == -1 ? 2 : 1) {
      // [\"]
      case 0:
        var startPos0 = _startPos;
        // => '"'
        $$ = '\"';
        success = true;
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }
        // <= '"'
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '"'
      _failure(_expect2);
    }
    // <= '"' # Choice
    _addToCache($$, pos, 30);
    _endToken();
    return $$;
  }
  
  dynamic _parse_STRING() {
    // LEXEME
    // STRING <- QUOTATION_MARK STRING_CHARS QUOTATION_MARK WS
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(16);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => QUOTATION_MARK STRING_CHARS QUOTATION_MARK WS # Choice
    switch (_ch == 34 ? 0 : _ch == -1 ? 2 : 1) {
      // [\"]
      case 0:
        // => QUOTATION_MARK STRING_CHARS QUOTATION_MARK WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => QUOTATION_MARK
          $$ = _parse_QUOTATION_MARK();
          // <= QUOTATION_MARK
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => STRING_CHARS
          $$ = _parse_STRING_CHARS();
          // <= STRING_CHARS
          if (!success) break;
          seq[1] = $$;
          // => QUOTATION_MARK
          $$ = _parse_QUOTATION_MARK();
          // <= QUOTATION_MARK
          if (!success) break;
          seq[2] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // QUOTATION_MARK
            final $1 = seq[0];
            // STRING_CHARS
            final $2 = seq[1];
            // QUOTATION_MARK
            final $3 = seq[2];
            // WS
            final $4 = seq[3];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= QUOTATION_MARK STRING_CHARS QUOTATION_MARK WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '"'
      _failure(_expect2);
    }
    // <= QUOTATION_MARK STRING_CHARS QUOTATION_MARK WS # Choice
    _addToCache($$, pos, 16);
    return $$;
  }
  
  dynamic _parse_STRING_CHARS() {
    // MORPHEME
    // STRING_CHARS <- CHAR*
    var $$;
    _beginToken(12);  
    // => CHAR* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => CHAR*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => CHAR
          $$ = _parse_CHAR();
          // <= CHAR
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= CHAR*
        if (success) {    
          // CHAR*
          final $1 = $$;
          $$ = $1.join();
        }
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: STRING_CHARS
      _failure(_expect25);
    }
    // <= CHAR* # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_TRUE() {
    // LEXEME
    // TRUE <- 'true' WS
    var $$;
    // => 'true' WS # Choice
    switch (_ch == 116 ? 0 : _ch == -1 ? 2 : 1) {
      // [t]
      case 0:
        // => 'true' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'true'
          $$ = _matchString(_strings2, 'true');
          // <= 'true'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // 'true'
            final $1 = seq[0];
            // WS
            final $2 = seq[1];
            $$ = true;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'true' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'true'
      _failure(_expect12);
    }
    // <= 'true' WS # Choice
    return $$;
  }
  
  dynamic _parse_UNESCAPED() {
    // MORPHEME
    // UNESCAPED <- [ -!] / [#-\[] / [\]-~] / [\]-\u10ffff]
    var $$;
    _beginToken(13);  
    // => [ -!] / [#-\[] / [\]-~] / [\]-\u10ffff] # Choice
    switch (_getState(_transitions9)) {
      // [ -!]
      case 0:
        var startPos0 = _startPos;
        // => [ -!]
        $$ = _matchRange(32, 33);
        // <= [ -!]
        _startPos = startPos0;
        break;
      // [#-[]
      case 1:
        var startPos1 = _startPos;
        // => [#-\[]
        $$ = _matchRange(35, 91);
        // <= [#-\[]
        _startPos = startPos1;
        break;
      // []-~]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          // => [\]-~]
          $$ = _matchRange(93, 126);
          // <= [\]-~]
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          // => [\]-\u10ffff]
          $$ = _matchRange(93, 1114111);
          // <= [\]-\u10ffff]
          _startPos = startPos3;
          break;
        }
        break;
      // [\u007f-\u0010ffff]
      case 3:
        var startPos4 = _startPos;
        // => [\]-\u10ffff]
        $$ = _matchRange(93, 1114111);
        // <= [\]-\u10ffff]
        _startPos = startPos4;
        break;
      // No matches
      // EOF
      case 4:
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: UNESCAPED
      _failure(_expect26);
    }
    // <= [ -!] / [#-\[] / [\]-~] / [\]-\u10ffff] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_VALUE_SEPARATOR() {
    // LEXEME
    // VALUE_SEPARATOR <- ',' WS
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(18);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => ',' WS # Choice
    switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
      // [,]
      case 0:
        // => ',' WS # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ','
          $$ = ',';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ','
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => WS
          $$ = _parse_WS();
          // <= WS
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ',' WS # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ','
      _failure(_expect3);
    }
    // <= ',' WS # Choice
    _addToCache($$, pos, 18);
    return $$;
  }
  
  dynamic _parse_WS() {
    // LEXEME & MORPHEME
    // WS <- [\t-\n\r ]*
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(19);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(0);    
    // => [\t-\n\r ]* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => [\t-\n\r ]*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => [\t-\n\r ]
          $$ = _matchMapping(9, 32, _mapping0);
          // <= [\t-\n\r ]
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= [\t-\n\r ]*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: WS
      _failure(_expect13);
    }
    // <= [\t-\n\r ]* # Choice
    _addToCache($$, pos, 19);
    _endToken();
    return $$;
  }
  
  dynamic _parse_array() {
    // NONTERMINAL
    // array <- BEGIN_ARRAY values? END_ARRAY
    var $$;
    // => BEGIN_ARRAY values? END_ARRAY # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => BEGIN_ARRAY values? END_ARRAY # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => BEGIN_ARRAY
          $$ = _parse_BEGIN_ARRAY();
          // <= BEGIN_ARRAY
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => values?
          var testing0 = _testing;
          _testing = _cursor;
          // => values
          $$ = _parse_values();
          // <= values
          success = true; 
          _testing = testing0;
          // <= values?
          if (!success) break;
          seq[1] = $$;
          // => END_ARRAY
          $$ = _parse_END_ARRAY();
          // <= END_ARRAY
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // BEGIN_ARRAY
            final $1 = seq[0];
            // values?
            final $2 = seq[1];
            // END_ARRAY
            final $3 = seq[2];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= BEGIN_ARRAY values? END_ARRAY # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect4);
    }
    // <= BEGIN_ARRAY values? END_ARRAY # Choice
    return $$;
  }
  
  dynamic _parse_member() {
    // NONTERMINAL
    // member <- STRING NAME_SEPARATOR value
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(4);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => STRING NAME_SEPARATOR value # Choice
    switch (_ch == 34 ? 0 : _ch == -1 ? 2 : 1) {
      // [\"]
      case 0:
        // => STRING NAME_SEPARATOR value # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => STRING
          $$ = _parse_STRING();
          // <= STRING
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => NAME_SEPARATOR
          $$ = _parse_NAME_SEPARATOR();
          // <= NAME_SEPARATOR
          if (!success) break;
          seq[1] = $$;
          // => value
          $$ = _parse_value();
          // <= value
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // STRING
            final $1 = seq[0];
            // NAME_SEPARATOR
            final $2 = seq[1];
            // value
            final $3 = seq[2];
            $$ = new _KeyValuePair($1, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= STRING NAME_SEPARATOR value # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '"'
      _failure(_expect2);
    }
    // <= STRING NAME_SEPARATOR value # Choice
    _addToCache($$, pos, 4);
    return $$;
  }
  
  dynamic _parse_members() {
    // NONTERMINAL
    // members <- member (VALUE_SEPARATOR member)*
    var $$;
    // => member (VALUE_SEPARATOR member)* # Choice
    switch (_ch == 34 ? 0 : _ch == -1 ? 2 : 1) {
      // [\"]
      case 0:
        // => member (VALUE_SEPARATOR member)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => member
          $$ = _parse_member();
          // <= member
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (VALUE_SEPARATOR member)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (VALUE_SEPARATOR member) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => VALUE_SEPARATOR member # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => VALUE_SEPARATOR
                  $$ = _parse_VALUE_SEPARATOR();
                  // <= VALUE_SEPARATOR
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => member
                  $$ = _parse_member();
                  // <= member
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= VALUE_SEPARATOR member # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect3);
            }
            // <= (VALUE_SEPARATOR member) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (VALUE_SEPARATOR member)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // member
            final $1 = seq[0];
            // (VALUE_SEPARATOR member)*
            final $2 = seq[1];
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= member (VALUE_SEPARATOR member)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '"'
      _failure(_expect2);
    }
    // <= member (VALUE_SEPARATOR member)* # Choice
    return $$;
  }
  
  dynamic _parse_object() {
    // NONTERMINAL
    // object <- BEGIN_OBJECT members? END_OBJECT
    var $$;
    // => BEGIN_OBJECT members? END_OBJECT # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => BEGIN_OBJECT members? END_OBJECT # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => BEGIN_OBJECT
          $$ = _parse_BEGIN_OBJECT();
          // <= BEGIN_OBJECT
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => members?
          var testing0 = _testing;
          _testing = _cursor;
          // => members
          $$ = _parse_members();
          // <= members
          success = true; 
          _testing = testing0;
          // <= members?
          if (!success) break;
          seq[1] = $$;
          // => END_OBJECT
          $$ = _parse_END_OBJECT();
          // <= END_OBJECT
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // BEGIN_OBJECT
            final $1 = seq[0];
            // members?
            final $2 = seq[1];
            // END_OBJECT
            final $3 = seq[2];
            $$ = $2.fold({}, (p, c) => p..[c.key] = c.value);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= BEGIN_OBJECT members? END_OBJECT # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect1);
    }
    // <= BEGIN_OBJECT members? END_OBJECT # Choice
    return $$;
  }
  
  dynamic _parse_value() {
    // NONTERMINAL
    // value <- FALSE / NULL / TRUE / object / array / NUMBER / STRING
    var $$;        
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(1);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => FALSE / NULL / TRUE / object / array / NUMBER / STRING # Choice
    switch (_getState(_transitions0)) {
      // [\"]
      case 0:
        var startPos0 = _startPos;
        // => STRING
        $$ = _parse_STRING();
        // <= STRING
        _startPos = startPos0;
        break;
      // [-] [0-9]
      case 1:
        var startPos1 = _startPos;
        // => NUMBER
        $$ = _parse_NUMBER();
        // <= NUMBER
        _startPos = startPos1;
        break;
      // [[]
      case 2:
        var startPos2 = _startPos;
        // => array
        $$ = _parse_array();
        // <= array
        _startPos = startPos2;
        break;
      // [f]
      case 3:
        var startPos3 = _startPos;
        // => FALSE
        $$ = _parse_FALSE();
        // <= FALSE
        _startPos = startPos3;
        break;
      // [n]
      case 4:
        var startPos4 = _startPos;
        // => NULL
        $$ = _parse_NULL();
        // <= NULL
        _startPos = startPos4;
        break;
      // [t]
      case 5:
        var startPos5 = _startPos;
        // => TRUE
        $$ = _parse_TRUE();
        // <= TRUE
        _startPos = startPos5;
        break;
      // [{]
      case 6:
        var startPos6 = _startPos;
        // => object
        $$ = _parse_object();
        // <= object
        _startPos = startPos6;
        break;
      // No matches
      // EOF
      case 7:
      case 8:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'false', 'null', 'true', '{', '[', NUMBER, '"'
      _failure(_expect0);
    }
    // <= FALSE / NULL / TRUE / object / array / NUMBER / STRING # Choice
    _addToCache($$, pos, 1);
    return $$;
  }
  
  dynamic _parse_values() {
    // NONTERMINAL
    // values <- value (VALUE_SEPARATOR value)*
    var $$;
    // => value (VALUE_SEPARATOR value)* # Choice
    switch (_getState(_transitions1)) {
      // [\"] [-] [0-9] [[] [f] [n] [t] [{]
      case 0:
        // => value (VALUE_SEPARATOR value)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => value
          $$ = _parse_value();
          // <= value
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (VALUE_SEPARATOR value)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (VALUE_SEPARATOR value) # Choice
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              // [,]
              case 0:
                // => VALUE_SEPARATOR value # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => VALUE_SEPARATOR
                  $$ = _parse_VALUE_SEPARATOR();
                  // <= VALUE_SEPARATOR
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => value
                  $$ = _parse_value();
                  // <= value
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= VALUE_SEPARATOR value # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: ','
              _failure(_expect3);
            }
            // <= (VALUE_SEPARATOR value) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (VALUE_SEPARATOR value)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // value
            final $1 = seq[0];
            // (VALUE_SEPARATOR value)*
            final $2 = seq[1];
            $$ = _list($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= value (VALUE_SEPARATOR value)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'false', 'null', 'true', '{', '[', NUMBER, '"'
      _failure(_expect0);
    }
    // <= value (VALUE_SEPARATOR value)* # Choice
    return $$;
  }
  
  String _text() {
    return new String.fromCharCodes(_input.sublist(_startPos, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<JsonParserError> errors() {
    if (success) {
      return <JsonParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <JsonParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<JsonParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new JsonParserError(JsonParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new JsonParserError(JsonParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_jsonText() {
    // NONTERMINAL
    // jsonText <- WS? value EOF
    var $$;
    // => WS? value EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        // => WS? value EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => WS?
          var testing0 = _testing;
          _testing = _cursor;
          // => WS
          $$ = _parse_WS();
          // <= WS
          success = true; 
          _testing = testing0;
          // <= WS?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => value
          $$ = _parse_value();
          // <= value
          if (!success) break;
          seq[1] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // WS?
            final $1 = seq[0];
            // value
            final $2 = seq[1];
            // EOF
            final $3 = seq[2];
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= WS? value EOF # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: 'false', 'null', 'true', '{', '[', NUMBER, '"'
      _failure(_expect0);
    }
    // <= WS? value EOF # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List(_inputLen + 1);
    _cachePos = -1;
    _cacheRule = new List(_inputLen + 1);
    _cacheState = new List.filled(((_inputLen + 1) >> 5) + 1, 0);
    _ch = -1;
    _errors = <JsonParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenLevel = 0;
    _tokenStart = null;
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class JsonParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  JsonParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is JsonParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

