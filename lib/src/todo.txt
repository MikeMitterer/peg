=======================================

Main task is "Nondeterministic finite automaton"

Suitable for
- Symbol transitions implementation
- Error recovering implementation
- More in-depth analysis of the (correctness of the) grammars

=======================================

Add public API of the parser generator

=======================================

Document (private) API of parser:
- _cursor
- _flatten
- _inputLen
- _token
- _tokenStart

Document (public) API of parser:
- calculatePos
- column
- errors !!!
- expected ???
- line
- unexpected ???

=======================================

Add conception of parser errors

Add member "get:errors" into generated parser class

abstract class XXXParserError {
  ParserErrorTypes type;
  int position;
  String to String();
}

class XXXParserErrorTypes {
  static const ParserErrorTypes XXX;
}

=======================================

Add public API of the parser generator

=======================================

Add support of "error recovering"

=======================================

Add detection and error reporing of unterminated tokens (terminals)

=======================================

Make public
_calcucatePos

=======================================

Add support of subterminals
- Subterminals resolver
- In-parsing going inside the subterminals from terminals
- Improve error messages (going inside the subterminals from terminals)

=======================================

rewrite "duplicate data remover" in general parser generator

=======================================

Interpreter: places of expectation error reporting:

choice: report all if no transitions

sequence: not report

unary: not report

terminal: report

TERMINAL <- "abc" / [0..9] # TERMINAL

TERMINAL <- "abc" # abc

Add property: Expression.hasCharacterClass
---
production rule: depends on memoization
  report all if not cached

=======================================

Renaming

Nullable
MayAdvance
MayFail

=======================================

Hide sub-terminals failure messages
FLAG
use in failure (sub terminals)
use in memoization

========================================

Remove Utils.charToString() and other related to strings

========================================

optimize lookahead expressions
(_ch >= 48 && _ch <= 57 && _lookahead[_ch + 81])
(_ch == 48 || _ch == 57) {
(_ch == 48 || _ch == 57  || _ch == 59)
(_ch >= 48 && _ch <= 57)
(_ch >= 48 && _ch <= 57 || _ch >= 91 && _ch <= 93)

========================================

TEST: choice with optional expression

========================================

parse([int position = 0]) {
  reset(position);
  return parseXXXSTART_RULE();
}

========================================

AND action:
 & { $$ = true; }

 ========================================

 Improve "expected" names via:
  _failure with flag?
  subterminals

========================================

lookahead optional w/o action (return default values)

========================================

REFACTOR constructors

========================================

Print
 sort:
   - none
   - tree
   - hierarchy
 group:
   nonterminals, terminals
 detail: *short full

sort 1:
a <- b c d
b <- b1
b1 <-
c <- c1
c1 <-
d <- d1
d1 <-

sort 2:
a <- b c d
b <- b1
c <- c1
d <- d1
b1 <-
c1 <-
d1 <-

=======================================

Doc comments

Eg.

/**
 * Parses the 'Grammar'.
 *
 * NONTERMINAL
 * Grammar <- SPACING Globals? Members? Definition+ EOF
 */
 dynamic parse_Grammar() {
 }

=======================================

Add support of detection "grammar does not requires a memoization"
