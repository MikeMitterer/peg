// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

import 'package:peg/expressions.dart';
import 'package:peg/grammar.dart';
import 'package:peg/production_rule.dart';

int _escape(int c) {
  switch (c) {
    case 110:
      return 10;      
    case 114:
      return 13;      
    case 116:
      return 9;      
  }    
  return c;
}

Expression _prefix(dynamic prefix, Expression expression, String action) {  
  switch (prefix) {
    case '&':
     expression = new AndPredicateExpression(expression);
     break;
    case '!':
     expression = new NotPredicateExpression(expression);
     break;        
  }
  expression.action = action;
  return expression;
}

Expression _suffix(String suffix, Expression expression) {
  switch (suffix) {
    case '?':
      return new OptionalExpression(expression);
    case '*':
      return  new ZeroOrMoreExpression(expression);
    case '+':
      return new OneOrMoreExpression(expression);        
  }
  return expression;
}
class PegParser {
  static const int EOF = -1;
  static final List<bool> _lookahead = _unmap([0x14800013, 0x7e000000, 0x7d0fffff, 0x38ffffff, 0x7f800010, 0x7f47ffff, 0x30fffff, 0x7ff80001, 0x7ff47fff, 0x1ffffff, 0x7fffffe, 0xffffffd]);
  // '\"', '\'', '-', '[', '\\', ']', 'n', 'r', 't'
  static final List<bool> _mapping0 = _unmap([0x821, 0x1c000000, 0x144000]);
  // '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'
  static final List<bool> _mapping1 = _unmap([0x7e03ff, 0xfc0000]);
  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping2 = _unmap([0x43ffffff, 0x7fffffe]);
  bool success;
  List _cache;
  int _cachePos;
  List<int> _cacheRule;
  List<int> _cacheState;
  int _ch;
  int _column;
  List<String> _expected;
  int _failurePos;
  int _flag;
  int _inputLen;
  int _inputPos;
  int _line;
  int _testing;
  String _text;
  
  PegParser(String text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }
    _text = text;  
    _inputLen = _text.length;
    if (_inputLen >= 0x3fffffe8 / 32) {
      throw new StateError('File size to big: $_inputLen');
    }  
    reset(0);    
  }
  
  int get column { 
    if (_column == -1) { 
      _calculatePos(_failurePos); 
    } 
    return _column;       
  } 
   
  int get line { 
    if (_line == -1) { 
      _calculatePos(_failurePos); 
    } 
    return _line;       
  } 
   
  void _addToCache(dynamic result, int start, int id) {  
    var cached = _cache[start];
    if (cached == null) {
      _cacheRule[start] = id;
      _cache[start] = [result, _inputPos, success];
    } else {    
      var slot = start >> 5;
      var r1 = (slot << 5) & 0x3fffffff;    
      var mask = 1 << (start - r1);    
      if ((_cacheState[slot] & mask) == 0) {
        _cacheState[slot] |= mask;   
        cached = [new List.filled(3, 0), new Map<int, List>()];
        _cache[start] = cached;                                      
      }
      slot = id >> 5;
      r1 = (slot << 5) & 0x3fffffff;    
      mask = 1 << (id - r1);    
      cached[0][slot] |= mask;
      cached[1][id] = [result, _inputPos, success];      
    }
    if (_cachePos < start) {
      _cachePos = start;
    }    
  }
  
  void _calculatePos(int pos) {
    if (pos == null || pos < 0 || pos > _inputLen) {
      return;
    }
    _line = 1;
    _column = 1;
    for (var i = 0; i < _inputLen && i < pos; i++) {
      var c = _text.codeUnitAt(i);
      if (c == 13) {
        _line++;
        _column = 1;
        if (i + 1 < _inputLen && _text.codeUnitAt(i + 1) == 10) {
          i++;
        }
      } else if (c == 10) {
        _line++;
        _column = 1;
      } else {
        _column++;
      }
    }
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _inputPos) {
      return;
    }
    if (_inputPos > _failurePos) {    
      _expected = [];
     _failurePos = _inputPos;
    }
    if (expected != null) {
      _expected.addAll(expected);
    }  
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    var result = _cache[_inputPos];
    if (result == null) {
      return null;
    }    
    var slot = _inputPos >> 5;
    var r1 = (slot << 5) & 0x3fffffff;  
    var mask = 1 << (_inputPos - r1);
    if ((_cacheState[slot] & mask) == 0) {
      if (_cacheRule[_inputPos] == id) {      
        _inputPos = result[1];
        success = result[2];      
        if (_inputPos < _inputLen) {
          _ch = _text.codeUnitAt(_inputPos);
        } else {
          _ch = EOF;
        }      
        return result;
      } else {
        return null;
      }    
    }
    slot = id >> 5;
    r1 = (slot << 5) & 0x3fffffff;  
    mask = 1 << (id - r1);
    if ((result[0][slot] & mask) == 0) {
      return null;
    }
    var data = result[1][id];  
    _inputPos = data[1];
    success = data[2];
    if (_inputPos < _inputLen) {
      _ch = _text.codeUnitAt(_inputPos);
    } else {
      _ch = EOF;
    }   
    return data;  
  }
  
  String _matchAny() {
    success = _inputPos < _inputLen;
    if (success) {
      var result = _text[_inputPos++];
      if (_inputPos < _inputLen) {
        _ch = _text.codeUnitAt(_inputPos);
      } else {
        _ch = EOF;
      }    
      return result;
    }
    if (_inputPos > _testing) {
      _failure();
    }  
    return null;  
  }
  
  String _matchChar(int ch, List<String> expected) {
    success = _ch == ch;
    if (success) {
      var result = _text[_inputPos++];
      if (_inputPos < _inputLen) {
        _ch = _text.codeUnitAt(_inputPos);
      } else {
        _ch = EOF;
      }    
      return result;
    }
    if (_inputPos > _testing) {
      _failure(expected);
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        var result = _text[_inputPos++];
        if (_inputPos < _inputLen) {
          _ch = _text.codeUnitAt(_inputPos);
        } else {
          _ch = EOF;
        }      
        return result;
      }
      success = false;
    }
    if (_inputPos > _testing) {
       _failure();
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) { 
      var result = _text[_inputPos++];
      if (_inputPos < _inputLen) {
        _ch = _text.codeUnitAt(_inputPos);
      } else {
        _ch = EOF;
      }  
      return result;
    }
    if (_inputPos > _testing) {
      _failure();
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {
      if (_ch <= ranges[i + 1]) {
        if (_ch >= ranges[i]) {
          var result = _text[_inputPos++];
          if (_inputPos < _inputLen) {
            _ch = _text.codeUnitAt(_inputPos);
          } else {
             _ch = EOF;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    if (_inputPos > _testing) {
      _failure();
    }
    success = false;  
    return null;  
  }
  
  String _matchString(String string, List<String> expected) {
    success = _text.startsWith(string, _inputPos);
    if (success) {
      _inputPos += string.length;      
      if (_inputPos < _inputLen) {
        _ch = _text.codeUnitAt(_inputPos);
      } else {
        _ch = EOF;
      }    
      return string;      
    } 
    if (_inputPos > _testing) {
      _failure(expected);
    }  
    return null; 
  }
  
  void _nextChar([int count = 1]) {  
    success = true;
    _inputPos += count; 
    if (_inputPos < _inputLen) {
      _ch = _text.codeUnitAt(_inputPos);
    } else {
      _ch = EOF;
    }    
  }
  
  bool _testChar(int c, int flag) {
    if (c < 0 || c > 127) {
      return false;
    }    
    int slot = (c & 0xff) >> 6;  
    int mask = 1 << c - ((slot << 6) & 0x3fffffff);  
    if ((flag & mask) != 0) {    
      return true;
    }
    return false;           
  }
  
  bool _testInput(int flag) {
    if (_inputPos >= _inputLen) {
      return false;
    }
    var c = _text.codeUnitAt(_inputPos);
    if (c < 0 || c > 127) {
      return false;
    }    
    int slot = (c & 0xff) >> 6;  
    int mask = 1 << c - ((slot << 6) & 0x3fffffff);  
    if ((flag & mask) != 0) {    
      return true;
    }
    return false;           
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<String> get expected {
    var set = new Set<String>();  
    set.addAll(_expected);
    if (set.contains(null)) {
      set.clear();
    }  
    var result = set.toList();
    result.sort(); 
    return result;        
  }
  
  dynamic parse_AND() {
    // TERMINAL
    // AND <- "&" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "&"
      $$ = _matchString('&', const ["&"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // "&"
        final $1 = seq[0];
        // SPACING
        final $2 = seq[1];
        $$ = $1;    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Action() {
    // NONTERMINAL
    // Action <- "{" ActionBody* "}" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "{"
      $$ = _matchString('{', const ["{"]);
      if (!success) break;
      var seq = new List(4);
      seq[0] = $$;
      // ActionBody*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        // ActionBody
        $$ = parse_ActionBody();
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      // "}"
      $$ = _matchString('}', const ["}"]);
      if (!success) break;
      seq[2] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[3] = $$;
      $$ = seq;
      if (success) {    
        // "{"
        final $1 = seq[0];
        // ActionBody*
        final $2 = seq[1];
        // "}"
        final $3 = seq[2];
        // SPACING
        final $4 = seq[3];
        $$ = _flatten([$1, $2, $3, $4]).join();    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_ActionBody() {
    // NONTERMINAL
    // ActionBody <- Action / !"}" .
    var $$;  
    while (true) {
      // Action
      if (_ch == 123) $$ = parse_Action();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["{"]);  
      }
      if (success) break;
      var ch0 = _ch;
      var pos0 = _inputPos;
      while (true) {  
        // !"}"
        var ch1 = _ch;
        var pos1 = _inputPos;
        var testing0 = _testing; 
        _testing = _inputLen + 1;
        // "}"
        $$ = _matchString('}', const ["}"]);
        _ch = ch1;
        _inputPos = pos1; 
        _testing = testing0;
        $$ = null;
        success = !success;
        if (!success && _inputPos > _testing) _failure();
        if (!success) break;
        var seq = new List(2);
        seq[0] = $$;
        // .
        $$ = _matchAny();
        if (!success) break;
        seq[1] = $$;
        $$ = seq;
        if (success) {    
          // !"}"
          final $1 = seq[0];
          // .
          final $2 = seq[1];
          $$ = $2;    
        }
        break;  
      }
      if (!success) {
        _ch = ch0;
        _inputPos = pos0;
      }
      break;
    }
    return $$;
  }
  
  dynamic parse_CLOSE() {
    // TERMINAL
    // CLOSE <- ")" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // ")"
      $$ = _matchString(')', const [")"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_COMMENT() {
    // TERMINAL
    // COMMENT <- "#" (!EOL .)* EOL
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "#"
      $$ = _matchString('#', const ["#"]);
      if (!success) break;
      var seq = new List(3);
      seq[0] = $$;
      // (!EOL .)*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        var ch1 = _ch;
        var pos1 = _inputPos;
        while (true) {  
          // !EOL
          var ch2 = _ch;
          var pos2 = _inputPos;
          var testing1 = _testing; 
          _testing = _inputLen + 1;
          // EOL
          if (_ch >= 10 && _ch <= 13 && _lookahead[_ch + -9]) {
            $$ = parse_EOL();
          }    
          else {
            success = false;  
            $$ = null;
            if (_inputPos > _testing) _failure(const ["\\r\\n", "\\n", "\\r"]);  
          }
          _ch = ch2;
          _inputPos = pos2; 
          _testing = testing1;
          $$ = null;
          success = !success;
          if (!success && _inputPos > _testing) _failure();
          if (!success) break;
          var seq = new List(2);
          seq[0] = $$;
          // .
          $$ = _matchAny();
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;  
        }
        if (!success) {
          _ch = ch1;
          _inputPos = pos1;
        }
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      // EOL
      if (_ch >= 10 && _ch <= 13 && _lookahead[_ch + -9]) {
        $$ = parse_EOL();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(const ["\\r\\n", "\\n", "\\r"]);  
      }
      if (!success) break;
      seq[2] = $$;
      $$ = seq;
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Char() {
    // NONTERMINAL
    // Char <- "\\" ["'\-\[-\]nrt] / HEX_NUMBER / !"\\" .
    var $$;  
    while (true) {
      var ch0 = _ch;
      var pos0 = _inputPos;
      while (true) {  
        // "\\"
        $$ = _matchString('\\', const ["\\"]);
        if (!success) break;
        var seq = new List(2);
        seq[0] = $$;
        // ["'\-\[-\]nrt]
        $$ = _matchMapping(34, 116, _mapping0);
        if (!success) break;
        seq[1] = $$;
        $$ = seq;
        if (success) {    
          // "\\"
          final $1 = seq[0];
          // ["'\-\[-\]nrt]
          final $2 = seq[1];
          $$ = _escape($2.codeUnitAt(0));    
        }
        break;  
      }
      if (!success) {
        _ch = ch0;
        _inputPos = pos0;
      }
      if (success) break;
      // HEX_NUMBER
      if (_ch == 92) $$ = parse_HEX_NUMBER();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["\\u"]);  
      }
      if (success) break;
      var ch1 = _ch;
      var pos1 = _inputPos;
      while (true) {  
        // !"\\"
        var ch2 = _ch;
        var pos2 = _inputPos;
        var testing0 = _testing; 
        _testing = _inputLen + 1;
        // "\\"
        $$ = _matchString('\\', const ["\\"]);
        _ch = ch2;
        _inputPos = pos2; 
        _testing = testing0;
        $$ = null;
        success = !success;
        if (!success && _inputPos > _testing) _failure();
        if (!success) break;
        var seq = new List(2);
        seq[0] = $$;
        // .
        $$ = _matchAny();
        if (!success) break;
        seq[1] = $$;
        $$ = seq;
        if (success) {    
          // !"\\"
          final $1 = seq[0];
          // .
          final $2 = seq[1];
          $$ = $2.codeUnitAt(0);    
        }
        break;  
      }
      if (!success) {
        _ch = ch1;
        _inputPos = pos1;
      }
      break;
    }
    return $$;
  }
  
  dynamic parse_Class() {
    // NONTERMINAL
    // Class <- "[" (!"]" Range)* "]" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "["
      $$ = _matchString('[', const ["["]);
      if (!success) break;
      var seq = new List(4);
      seq[0] = $$;
      // (!"]" Range)*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        var ch1 = _ch;
        var pos1 = _inputPos;
        while (true) {  
          // !"]"
          var ch2 = _ch;
          var pos2 = _inputPos;
          var testing1 = _testing; 
          _testing = _inputLen + 1;
          // "]"
          $$ = _matchString(']', const ["]"]);
          _ch = ch2;
          _inputPos = pos2; 
          _testing = testing1;
          $$ = null;
          success = !success;
          if (!success && _inputPos > _testing) _failure();
          if (!success) break;
          var seq = new List(2);
          seq[0] = $$;
          // Range
          $$ = parse_Range();
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !"]"
            final $1 = seq[0];
            // Range
            final $2 = seq[1];
            $$ = $2;    
          }
          break;  
        }
        if (!success) {
          _ch = ch1;
          _inputPos = pos1;
        }
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      // "]"
      $$ = _matchString(']', const ["]"]);
      if (!success) break;
      seq[2] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[3] = $$;
      $$ = seq;
      if (success) {    
        // "["
        final $1 = seq[0];
        // (!"]" Range)*
        final $2 = seq[1];
        // "]"
        final $3 = seq[2];
        // SPACING
        final $4 = seq[3];
        $$ = new CharacterClassExpression($2);    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_DOT() {
    // TERMINAL
    // DOT <- "." SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "."
      $$ = _matchString('.', const ["."]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Definition() {
    // NONTERMINAL
    // Definition <- IDENTIFIER LEFTARROW Expression
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // IDENTIFIER
      if (_ch >= 65 && _ch <= 122 && _lookahead[_ch + -9]) {
        $$ = parse_IDENTIFIER();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(const ["IDENTIFIER"]);  
      }
      if (!success) break;
      var seq = new List(3);
      seq[0] = $$;
      // LEFTARROW
      if (_ch == 60) $$ = parse_LEFTARROW();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["<-"]);  
      }
      if (!success) break;
      seq[1] = $$;
      // Expression
      if (_ch >= 33 && _ch <= 122 && _lookahead[_ch + 82]) {
        $$ = parse_Expression();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(null);  
      }
      if (!success) break;
      seq[2] = $$;
      $$ = seq;
      if (success) {    
        // IDENTIFIER
        final $1 = seq[0];
        // LEFTARROW
        final $2 = seq[1];
        // Expression
        final $3 = seq[2];
        $$ = new ProductionRule($1, $3);    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_EOF() {
    // TERMINAL
    // EOF <- !.
    var $$;  
    // !.
    var ch0 = _ch;
    var pos0 = _inputPos;
    var testing0 = _testing; 
    _testing = _inputLen + 1;
    // .
    $$ = _matchAny();
    _ch = ch0;
    _inputPos = pos0; 
    _testing = testing0;
    $$ = null;
    success = !success;
    if (!success && _inputPos > _testing) _failure();
    return $$;
  }
  
  dynamic parse_EOL() {
    // TERMINAL
    // EOL <- "\r\n" / "\n" / "\r"
    var $$;  
    while (true) {
      // "\r\n"
      $$ = _matchString('\r\n', const ["\\r\\n"]);
      if (success) break;
      // "\n"
      $$ = _matchString('\n', const ["\\n"]);
      if (success) break;
      // "\r"
      $$ = _matchString('\r', const ["\\r"]);
      break;
    }
    return $$;
  }
  
  dynamic parse_Expression() {
    // NONTERMINAL
    // Expression <- Sequence (SLASH Sequence)*
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // Sequence
      if (_ch >= 33 && _ch <= 122 && _lookahead[_ch + 82]) {
        $$ = parse_Sequence();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(null);  
      }
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // (SLASH Sequence)*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        var ch1 = _ch;
        var pos1 = _inputPos;
        while (true) {  
          // SLASH
          if (_ch == 47) $$ = parse_SLASH();
          else {  
           success = false;
           $$ = null;
           if (_inputPos > _testing) _failure(const ["/"]);  
          }
          if (!success) break;
          var seq = new List(2);
          seq[0] = $$;
          // Sequence
          if (_ch >= 33 && _ch <= 122 && _lookahead[_ch + 82]) {
            $$ = parse_Sequence();
          }    
          else {
            success = false;  
            $$ = null;
            if (_inputPos > _testing) _failure(null);  
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // SLASH
            final $1 = seq[0];
            // Sequence
            final $2 = seq[1];
            $$ = $2;    
          }
          break;  
        }
        if (!success) {
          _ch = ch1;
          _inputPos = pos1;
        }
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // Sequence
        final $1 = seq[0];
        // (SLASH Sequence)*
        final $2 = seq[1];
        $$ = new OrderedChoiceExpression(_flatten([$1, $2]));    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Globals() {
    // NONTERMINAL
    // Globals <- "%{" GlobalsBody* "}%" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "%{"
      $$ = _matchString('%{', const ["%{"]);
      if (!success) break;
      var seq = new List(4);
      seq[0] = $$;
      // GlobalsBody*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        // GlobalsBody
        $$ = parse_GlobalsBody();
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      // "}%"
      $$ = _matchString('}%', const ["}%"]);
      if (!success) break;
      seq[2] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[3] = $$;
      $$ = seq;
      if (success) {    
        // "%{"
        final $1 = seq[0];
        // GlobalsBody*
        final $2 = seq[1];
        // "}%"
        final $3 = seq[2];
        // SPACING
        final $4 = seq[3];
        $$ = _flatten(["{", $2, "}", $4]).join();    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_GlobalsBody() {
    // NONTERMINAL
    // GlobalsBody <- !"}%" .
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // !"}%"
      var ch1 = _ch;
      var pos1 = _inputPos;
      var testing0 = _testing; 
      _testing = _inputLen + 1;
      // "}%"
      $$ = _matchString('}%', const ["}%"]);
      _ch = ch1;
      _inputPos = pos1; 
      _testing = testing0;
      $$ = null;
      success = !success;
      if (!success && _inputPos > _testing) _failure();
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // .
      $$ = _matchAny();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // !"}%"
        final $1 = seq[0];
        // .
        final $2 = seq[1];
        $$ = $2;    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Grammar() {
    // NONTERMINAL
    // Grammar <- SPACING Globals? Members? Definition+ EOF
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      var seq = new List(5);
      seq[0] = $$;
      // Globals?
      var testing0 = _testing;
      _testing = _inputPos;
      // Globals
      if (_ch == 37) $$ = parse_Globals();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["%{"]);  
      }
      success = true; 
      _testing = testing0;
      if (!success) break;
      seq[1] = $$;
      // Members?
      var testing1 = _testing;
      _testing = _inputPos;
      // Members
      if (_ch == 123) $$ = parse_Members();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["{"]);  
      }
      success = true; 
      _testing = testing1;
      if (!success) break;
      seq[2] = $$;
      // Definition+
      var testing2;
      for (var first = true, reps; ;) {  
        // Definition  
        if (_ch >= 65 && _ch <= 122 && _lookahead[_ch + -9]) {  
          $$ = parse_Definition();  
        }      
        else {  
          success = false;    
          $$ = null;  
          if (_inputPos > _testing) _failure(null);    
        }  
        if (success) {
         if (first) {      
            first = false;
            reps = [$$];
            testing2 = _testing;                  
          } else {
            reps.add($$);
          }
          _testing = _inputPos;   
        } else {
          success = !first;
          if (success) {      
            _testing = testing2;
            $$ = reps;      
          } else $$ = null;
          break;
        }  
      }
      if (!success) break;
      seq[3] = $$;
      // EOF
      $$ = parse_EOF();
      if (!success) break;
      seq[4] = $$;
      $$ = seq;
      if (success) {    
        // SPACING
        final $1 = seq[0];
        // Globals?
        final $2 = seq[1];
        // Members?
        final $3 = seq[2];
        // Definition+
        final $4 = seq[3];
        // EOF
        final $5 = seq[4];
        $$ = new Grammar($4, $2, $3);    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_HEX_NUMBER() {
    // TERMINAL
    // HEX_NUMBER <- "\\u" [0-9A-Fa-f]+
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "\\u"
      $$ = _matchString('\\u', const ["\\u"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // [0-9A-Fa-f]+
      var testing0;
      for (var first = true, reps; ;) {  
        // [0-9A-Fa-f]  
        $$ = _matchMapping(48, 102, _mapping1);  
        if (success) {
         if (first) {      
            first = false;
            reps = [$$];
            testing0 = _testing;                  
          } else {
            reps.add($$);
          }
          _testing = _inputPos;   
        } else {
          success = !first;
          if (success) {      
            _testing = testing0;
            $$ = reps;      
          } else $$ = null;
          break;
        }  
      }
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // "\\u"
        final $1 = seq[0];
        // [0-9A-Fa-f]+
        final $2 = seq[1];
        $$ = int.parse($2.join(), radix: 16);    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_IDENTIFIER() {
    // TERMINAL
    // IDENTIFIER <- IDENT_START IDENT_CONT* SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // IDENT_START
      if (_ch >= 65 && _ch <= 122 && _lookahead[_ch + -9]) {
        $$ = parse_IDENT_START();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(const ["IDENT_START"]);  
      }
      if (!success) break;
      var seq = new List(3);
      seq[0] = $$;
      // IDENT_CONT*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        // IDENT_CONT
        if (_ch >= 48 && _ch <= 122 && _lookahead[_ch + 246]) {
          $$ = parse_IDENT_CONT();
        }    
        else {
          success = false;  
          $$ = null;
          if (_inputPos > _testing) _failure(const ["IDENT_CONT"]);  
        }
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[2] = $$;
      $$ = seq;
      if (success) {    
        // IDENT_START
        final $1 = seq[0];
        // IDENT_CONT*
        final $2 = seq[1];
        // SPACING
        final $3 = seq[2];
        $$ = _flatten([$1, $2]).join();    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_IDENT_CONT() {
    // TERMINAL
    // IDENT_CONT <- IDENT_START / [0-9]
    var $$;  
    while (true) {
      // IDENT_START
      if (_ch >= 65 && _ch <= 122 && _lookahead[_ch + -9]) {
        $$ = parse_IDENT_START();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(const ["IDENT_START"]);  
      }
      if (success) break;
      // [0-9]
      $$ = _matchRange(48, 57);
      break;
    }
    return $$;
  }
  
  dynamic parse_IDENT_START() {
    // TERMINAL
    // IDENT_START <- [A-Z_a-z]
    var $$;  
    // [A-Z_a-z]
    $$ = _matchMapping(65, 122, _mapping2);
    return $$;
  }
  
  dynamic parse_LEFTARROW() {
    // TERMINAL
    // LEFTARROW <- "<-" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "<-"
      $$ = _matchString('<-', const ["<-"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Literal() {
    // NONTERMINAL
    // Literal <- "\'" (!"\'" Char)* ['] SPACING / "\"" (!"\"" Char)* ["] SPACING
    var $$;  
    while (true) {
      var ch0 = _ch;
      var pos0 = _inputPos;
      while (true) {  
        // "\'"
        $$ = _matchString('\'', const ["\'"]);
        if (!success) break;
        var seq = new List(4);
        seq[0] = $$;
        // (!"\'" Char)*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _inputPos;
          var ch1 = _ch;
          var pos1 = _inputPos;
          while (true) {  
            // !"\'"
            var ch2 = _ch;
            var pos2 = _inputPos;
            var testing1 = _testing; 
            _testing = _inputLen + 1;
            // "\'"
            $$ = _matchString('\'', const ["\'"]);
            _ch = ch2;
            _inputPos = pos2; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success && _inputPos > _testing) _failure();
            if (!success) break;
            var seq = new List(2);
            seq[0] = $$;
            // Char
            $$ = parse_Char();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // !"\'"
              final $1 = seq[0];
              // Char
              final $2 = seq[1];
              $$ = $2;    
            }
            break;  
          }
          if (!success) {
            _ch = ch1;
            _inputPos = pos1;
          }
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        if (!success) break;
        seq[1] = $$;
        // [']
        $$ = _matchChar(39, const ["\'"]);
        if (!success) break;
        seq[2] = $$;
        // SPACING
        $$ = parse_SPACING();
        if (!success) break;
        seq[3] = $$;
        $$ = seq;
        if (success) {    
          // "\'"
          final $1 = seq[0];
          // (!"\'" Char)*
          final $2 = seq[1];
          // [']
          final $3 = seq[2];
          // SPACING
          final $4 = seq[3];
          $$ = new LiteralExpression(new String.fromCharCodes($2));    
        }
        break;  
      }
      if (!success) {
        _ch = ch0;
        _inputPos = pos0;
      }
      if (success) break;
      var ch3 = _ch;
      var pos3 = _inputPos;
      while (true) {  
        // "\""
        $$ = _matchString('\"', const ["\""]);
        if (!success) break;
        var seq = new List(4);
        seq[0] = $$;
        // (!"\"" Char)*
        var testing2 = _testing; 
        for (var reps = []; ; ) {
          _testing = _inputPos;
          var ch4 = _ch;
          var pos4 = _inputPos;
          while (true) {  
            // !"\""
            var ch5 = _ch;
            var pos5 = _inputPos;
            var testing3 = _testing; 
            _testing = _inputLen + 1;
            // "\""
            $$ = _matchString('\"', const ["\""]);
            _ch = ch5;
            _inputPos = pos5; 
            _testing = testing3;
            $$ = null;
            success = !success;
            if (!success && _inputPos > _testing) _failure();
            if (!success) break;
            var seq = new List(2);
            seq[0] = $$;
            // Char
            $$ = parse_Char();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // !"\""
              final $1 = seq[0];
              // Char
              final $2 = seq[1];
              $$ = $2;    
            }
            break;  
          }
          if (!success) {
            _ch = ch4;
            _inputPos = pos4;
          }
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing2;
            $$ = reps;
            break; 
          }
        }
        if (!success) break;
        seq[1] = $$;
        // ["]
        $$ = _matchChar(34, const ["\""]);
        if (!success) break;
        seq[2] = $$;
        // SPACING
        $$ = parse_SPACING();
        if (!success) break;
        seq[3] = $$;
        $$ = seq;
        if (success) {    
          // "\""
          final $1 = seq[0];
          // (!"\"" Char)*
          final $2 = seq[1];
          // ["]
          final $3 = seq[2];
          // SPACING
          final $4 = seq[3];
          $$ = new LiteralExpression(new String.fromCharCodes($2));    
        }
        break;  
      }
      if (!success) {
        _ch = ch3;
        _inputPos = pos3;
      }
      break;
    }
    return $$;
  }
  
  dynamic parse_Members() {
    // NONTERMINAL
    // Members <- "{" ActionBody* "}" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "{"
      $$ = _matchString('{', const ["{"]);
      if (!success) break;
      var seq = new List(4);
      seq[0] = $$;
      // ActionBody*
      var testing0 = _testing; 
      for (var reps = []; ; ) {
        _testing = _inputPos;
        // ActionBody
        $$ = parse_ActionBody();
        if (success) {  
          reps.add($$);
        } else {
          success = true;
          _testing = testing0;
          $$ = reps;
          break; 
        }
      }
      if (!success) break;
      seq[1] = $$;
      // "}"
      $$ = _matchString('}', const ["}"]);
      if (!success) break;
      seq[2] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[3] = $$;
      $$ = seq;
      if (success) {    
        // "{"
        final $1 = seq[0];
        // ActionBody*
        final $2 = seq[1];
        // "}"
        final $3 = seq[2];
        // SPACING
        final $4 = seq[3];
        $$ = _flatten([$1, $2, $3, $4]).join();    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_NOT() {
    // TERMINAL
    // NOT <- "!" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "!"
      $$ = _matchString('!', const ["!"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // "!"
        final $1 = seq[0];
        // SPACING
        final $2 = seq[1];
        $$ = $1;    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_OPEN() {
    // TERMINAL
    // OPEN <- "(" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "("
      $$ = _matchString('(', const ["("]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_PLUS() {
    // TERMINAL
    // PLUS <- "+" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "+"
      $$ = _matchString('+', const ["+"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // "+"
        final $1 = seq[0];
        // SPACING
        final $2 = seq[1];
        $$ = $1;    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Prefix() {
    // NONTERMINAL
    // Prefix <- (AND / NOT)? Suffix Action?
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // (AND / NOT)?
      var testing0 = _testing;
      _testing = _inputPos;
      while (true) {
        // AND
        if (_ch == 38) $$ = parse_AND();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["&"]);  
        }
        if (success) break;
        // NOT
        if (_ch == 33) $$ = parse_NOT();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["!"]);  
        }
        break;
      }
      success = true; 
      _testing = testing0;
      if (!success) break;
      var seq = new List(3);
      seq[0] = $$;
      // Suffix
      if (_ch >= 34 && _ch <= 122 && _lookahead[_ch + 171]) {
        $$ = parse_Suffix();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(null);  
      }
      if (!success) break;
      seq[1] = $$;
      // Action?
      var testing1 = _testing;
      _testing = _inputPos;
      // Action
      if (_ch == 123) $$ = parse_Action();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["{"]);  
      }
      success = true; 
      _testing = testing1;
      if (!success) break;
      seq[2] = $$;
      $$ = seq;
      if (success) {    
        // (AND / NOT)?
        final $1 = seq[0];
        // Suffix
        final $2 = seq[1];
        // Action?
        final $3 = seq[2];
        $$ = _prefix($1, $2, $3);    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Primary() {
    // NONTERMINAL
    // Primary <- IDENTIFIER !LEFTARROW / OPEN Expression CLOSE / Literal / Class / DOT
    var $$;  
    while (true) {
      var ch0 = _ch;
      var pos0 = _inputPos;
      while (true) {  
        // IDENTIFIER
        if (_ch >= 65 && _ch <= 122 && _lookahead[_ch + -9]) {
          $$ = parse_IDENTIFIER();
        }    
        else {
          success = false;  
          $$ = null;
          if (_inputPos > _testing) _failure(const ["IDENTIFIER"]);  
        }
        if (!success) break;
        var seq = new List(2);
        seq[0] = $$;
        // !LEFTARROW
        var ch1 = _ch;
        var pos1 = _inputPos;
        var testing0 = _testing; 
        _testing = _inputLen + 1;
        // LEFTARROW
        if (_ch == 60) $$ = parse_LEFTARROW();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["<-"]);  
        }
        _ch = ch1;
        _inputPos = pos1; 
        _testing = testing0;
        $$ = null;
        success = !success;
        if (!success && _inputPos > _testing) _failure();
        if (!success) break;
        seq[1] = $$;
        $$ = seq;
        if (success) {    
          // IDENTIFIER
          final $1 = seq[0];
          // !LEFTARROW
          final $2 = seq[1];
          $$ = new RuleExpression($1);    
        }
        break;  
      }
      if (!success) {
        _ch = ch0;
        _inputPos = pos0;
      }
      if (success) break;
      var ch2 = _ch;
      var pos2 = _inputPos;
      while (true) {  
        // OPEN
        if (_ch == 40) $$ = parse_OPEN();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["("]);  
        }
        if (!success) break;
        var seq = new List(3);
        seq[0] = $$;
        // Expression
        if (_ch >= 33 && _ch <= 122 && _lookahead[_ch + 82]) {
          $$ = parse_Expression();
        }    
        else {
          success = false;  
          $$ = null;
          if (_inputPos > _testing) _failure(null);  
        }
        if (!success) break;
        seq[1] = $$;
        // CLOSE
        if (_ch == 41) $$ = parse_CLOSE();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const [")"]);  
        }
        if (!success) break;
        seq[2] = $$;
        $$ = seq;
        if (success) {    
          // OPEN
          final $1 = seq[0];
          // Expression
          final $2 = seq[1];
          // CLOSE
          final $3 = seq[2];
          $$ = $2;    
        }
        break;  
      }
      if (!success) {
        _ch = ch2;
        _inputPos = pos2;
      }
      if (success) break;
      // Literal
      if (_ch >= 34 && _ch <= 39 && _lookahead[_ch + 47]) {
        $$ = parse_Literal();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(const ["\'", "\""]);  
      }
      if (success) break;
      // Class
      if (_ch == 91) $$ = parse_Class();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["["]);  
      }
      if (success) break;
      // DOT
      if (_ch == 46) $$ = parse_DOT();
      else {  
       success = false;
       $$ = null;
       if (_inputPos > _testing) _failure(const ["."]);  
      }
      if (success) {    
        // DOT
        final $1 = $$;
        $$ = new AnyCharacterExpression();    
      }
      break;
    }
    return $$;
  }
  
  dynamic parse_QUESTION() {
    // TERMINAL
    // QUESTION <- "?" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "?"
      $$ = _matchString('?', const ["?"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // "?"
        final $1 = seq[0];
        // SPACING
        final $2 = seq[1];
        $$ = $1;    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Range() {
    // NONTERMINAL
    // Range <- Char "-" Char / Char
    var $$;  
    while (true) {
      var ch0 = _ch;
      var pos0 = _inputPos;
      while (true) {  
        // Char
        $$ = parse_Char();
        if (!success) break;
        var seq = new List(3);
        seq[0] = $$;
        // "-"
        $$ = _matchString('-', const ["-"]);
        if (!success) break;
        seq[1] = $$;
        // Char
        $$ = parse_Char();
        if (!success) break;
        seq[2] = $$;
        $$ = seq;
        if (success) {    
          // Char
          final $1 = seq[0];
          // "-"
          final $2 = seq[1];
          // Char
          final $3 = seq[2];
          $$ = [$1, $3];    
        }
        break;  
      }
      if (!success) {
        _ch = ch0;
        _inputPos = pos0;
      }
      if (success) break;
      // Char
      $$ = parse_Char();
      if (success) {    
        // Char
        final $1 = $$;
        $$ = [$1, $1];    
      }
      break;
    }
    return $$;
  }
  
  dynamic parse_SLASH() {
    // TERMINAL
    // SLASH <- "/" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "/"
      $$ = _matchString('/', const ["/"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_SPACE() {
    // TERMINAL
    // SPACE <- " " / "\t" / EOL
    var $$;  
    while (true) {
      // " "
      $$ = _matchString(' ', const [" "]);
      if (success) break;
      // "\t"
      $$ = _matchString('\t', const ["\\t"]);
      if (success) break;
      // EOL
      if (_ch >= 10 && _ch <= 13 && _lookahead[_ch + -9]) {
        $$ = parse_EOL();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(const ["\\r\\n", "\\n", "\\r"]);  
      }
      break;
    }
    return $$;
  }
  
  dynamic parse_SPACING() {
    // TERMINAL
    // SPACING <- (SPACE / COMMENT)*
    var $$;  
    // (SPACE / COMMENT)*
    var testing0 = _testing; 
    for (var reps = []; ; ) {
      _testing = _inputPos;
      while (true) {
        // SPACE
        if (_ch >= 9 && _ch <= 32 && _lookahead[_ch + -9]) {
          $$ = parse_SPACE();
        }    
        else {
          success = false;  
          $$ = null;
          if (_inputPos > _testing) _failure(const [" ", "\\t", "\\r\\n", "\\n", "\\r"]);  
        }
        if (success) break;
        // COMMENT
        if (_ch == 35) $$ = parse_COMMENT();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["#"]);  
        }
        break;
      }
      if (success) {  
        reps.add($$);
      } else {
        success = true;
        _testing = testing0;
        $$ = reps;
        break; 
      }
    }
    return $$;
  }
  
  dynamic parse_STAR() {
    // TERMINAL
    // STAR <- "*" SPACING
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // "*"
      $$ = _matchString('*', const ["*"]);
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // SPACING
      $$ = parse_SPACING();
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // "*"
        final $1 = seq[0];
        // SPACING
        final $2 = seq[1];
        $$ = $1;    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  dynamic parse_Sequence() {
    // NONTERMINAL
    // Sequence <- Prefix+
    var $$;  
    // Prefix+
    var testing0;
    for (var first = true, reps; ;) {  
      // Prefix  
      if (_ch >= 33 && _ch <= 122 && _lookahead[_ch + 82]) {  
        $$ = parse_Prefix();  
      }      
      else {  
        success = false;    
        $$ = null;  
        if (_inputPos > _testing) _failure(null);    
      }  
      if (success) {
       if (first) {      
          first = false;
          reps = [$$];
          testing0 = _testing;                  
        } else {
          reps.add($$);
        }
        _testing = _inputPos;   
      } else {
        success = !first;
        if (success) {      
          _testing = testing0;
          $$ = reps;      
        } else $$ = null;
        break;
      }  
    }
    if (success) {    
      // Prefix+
      final $1 = $$;
      $$ = new SequenceExpression($1);    
    }
    return $$;
  }
  
  dynamic parse_Suffix() {
    // NONTERMINAL
    // Suffix <- Primary (QUESTION / STAR / PLUS)?
    var $$;  
    var ch0 = _ch;
    var pos0 = _inputPos;
    while (true) {  
      // Primary
      if (_ch >= 34 && _ch <= 122 && _lookahead[_ch + 171]) {
        $$ = parse_Primary();
      }    
      else {
        success = false;  
        $$ = null;
        if (_inputPos > _testing) _failure(null);  
      }
      if (!success) break;
      var seq = new List(2);
      seq[0] = $$;
      // (QUESTION / STAR / PLUS)?
      var testing0 = _testing;
      _testing = _inputPos;
      while (true) {
        // QUESTION
        if (_ch == 63) $$ = parse_QUESTION();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["?"]);  
        }
        if (success) break;
        // STAR
        if (_ch == 42) $$ = parse_STAR();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["*"]);  
        }
        if (success) break;
        // PLUS
        if (_ch == 43) $$ = parse_PLUS();
        else {  
         success = false;
         $$ = null;
         if (_inputPos > _testing) _failure(const ["+"]);  
        }
        break;
      }
      success = true; 
      _testing = testing0;
      if (!success) break;
      seq[1] = $$;
      $$ = seq;
      if (success) {    
        // Primary
        final $1 = seq[0];
        // (QUESTION / STAR / PLUS)?
        final $2 = seq[1];
        $$ = _suffix($2, $1);    
      }
      break;  
    }
    if (!success) {
      _ch = ch0;
      _inputPos = pos0;
    }
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }
    success = true;    
    _cache = new List(_inputLen + 1);
    _cachePos = -1;
    _cacheRule = new List(_inputLen + 1);
    _cacheState = new List.filled(((_inputLen + 1) >> 5) + 1, 0);
    _ch = EOF;  
    _column = -1; 
    _expected = [];
    _failurePos = -1;
    _flag = 0;  
    _inputPos = pos;
    _line = -1;    
    _testing = -1;
    if (pos < _inputLen) {
      _ch = _text.codeUnitAt(pos);
    }    
  }
  
  String get unexpected {
    if (_failurePos < 0 || _failurePos >= _inputLen) {
      return '';    
    }
    return _text[_failurePos];      
  }
  
}

