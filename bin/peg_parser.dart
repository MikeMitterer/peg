// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

import 'package:peg/grammar/expressions.dart';
import 'package:peg/grammar/grammar.dart';
import 'package:peg/grammar/production_rule.dart';

int _escape(int c) {
  switch (c) {
    case 110:
      return 10;      
    case 114:
      return 13;      
    case 116:
      return 9;      
  }    
  return c;
}

Expression _prefix(dynamic prefix, Expression expression, String action) {  
  switch (prefix) {
    case '&':
     expression = new AndPredicateExpression(expression);
     break;
    case '!':
     expression = new NotPredicateExpression(expression);
     break;        
  }
  expression.action = action;
  return expression;
}

Expression _suffix(String suffix, Expression expression) {
  switch (suffix) {
    case '?':
      return new OptionalExpression(expression);
    case '*':
      return  new ZeroOrMoreExpression(expression);
    case '+':
      return new OneOrMoreExpression(expression);        
  }
  return expression;
}

class PegParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["IDENTIFIER"];
  
  static final List<String> _expect1 = <String>["\'(\'", "\'.\'", "\'[\'", "IDENTIFIER", "LITERAL"];
  
  static final List<String> _expect10 = <String>["\'.\'"];
  
  static final List<String> _expect11 = <String>["EOF"];
  
  static final List<String> _expect12 = <String>["\'%{\'"];
  
  static final List<String> _expect13 = <String>["\'<-\'"];
  
  static final List<String> _expect14 = <String>["LITERAL"];
  
  static final List<String> _expect15 = <String>["CHAR"];
  
  static final List<String> _expect16 = <String>["\'!\'"];
  
  static final List<String> _expect17 = <String>["\'(\'"];
  
  static final List<String> _expect18 = <String>["\'+\'"];
  
  static final List<String> _expect19 = <String>["\'?\'"];
  
  static final List<String> _expect2 = <String>["\'/\'"];
  
  static final List<String> _expect20 = <String>["SPACING"];
  
  static final List<String> _expect21 = <String>["\'#\'", "SPACE"];
  
  static final List<String> _expect22 = <String>["\'*\'"];
  
  static final List<String> _expect23 = <String>["ACTION_BODY"];
  
  static final List<String> _expect24 = <String>["\'#\'"];
  
  static final List<String> _expect25 = <String>[null];
  
  static final List<String> _expect26 = <String>["EOL"];
  
  static final List<String> _expect27 = <String>["GLOBALS_BODY"];
  
  static final List<String> _expect28 = <String>["HEX_NUMBER"];
  
  static final List<String> _expect29 = <String>["IDENT_CONT"];
  
  static final List<String> _expect3 = <String>["\'!\'", "\'&\'"];
  
  static final List<String> _expect30 = <String>["IDENT_START"];
  
  static final List<String> _expect31 = <String>["SPACE"];
  
  static final List<String> _expect4 = <String>["\'*\'", "\'+\'", "\'?\'"];
  
  static final List<String> _expect5 = <String>["\'{\'"];
  
  static final List<String> _expect6 = <String>["\'&\'"];
  
  static final List<String> _expect7 = <String>["\'[\'"];
  
  static final List<String> _expect8 = <String>["RANGE"];
  
  static final List<String> _expect9 = <String>["\')\'"];
  
  static final List<bool> _lookahead = _unmap([0x20e3, 0xffffffe, 0x1ffffffd, 0x7000020c, 0x68ffffff, 0x7fffffff, 0x7ffffc07, 0x7ffffa1f, 0x200004ff]);
  
  // '\"', '\'', '-', '[', '\\', ']', 'n', 'r', 't'
  static final List<bool> _mapping0 = _unmap([0x821, 0x1c000000, 0x144000]);
  
  // '\n', '\r'
  static final List<bool> _mapping1 = _unmap([0x9]);
  
  // '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'
  static final List<bool> _mapping2 = _unmap([0x7e03ff, 0xfc0000]);
  
  // 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping3 = _unmap([0x43ffffff, 0x7fffffe]);
  
  // '\t', ' '
  static final List<bool> _mapping4 = _unmap([0x800001]);
  
  // '%{'
  static final List<int> _strings0 = <int>[37, 123];
  
  // '}%'
  static final List<int> _strings1 = <int>[125, 37];
  
  // '<-'
  static final List<int> _strings2 = <int>[60, 45];
  
  // '\r\n'
  static final List<int> _strings3 = <int>[13, 10];
  
  final List<int> _tokenFlags = [1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0];
  
  final List<String> _tokenNames = ["SPACING", "ACTION_BODY", "CHAR", "\'#\'", "EOL", "GLOBALS_BODY", "HEX_NUMBER", "IDENT_CONT", "IDENT_START", "RANGE", "SPACE"];
  
  static final List<List<int>> _transitions0 = [[65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions1 = [[33, 34, 38, 40, 46, 46, 65, 91, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions10 = [[10, 10], [13, 13]];
  
  static final List<List<int>> _transitions11 = [[48, 57], [65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions12 = [[9, 9, 32, 32], [10, 10, 13, 13]];
  
  static final List<List<int>> _transitions2 = [[33, 33], [38, 38]];
  
  static final List<List<int>> _transitions3 = [[34, 34, 39, 40, 46, 46, 65, 91, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions4 = [[42, 42], [43, 43], [63, 63]];
  
  static final List<List<int>> _transitions5 = [[34, 34, 39, 39], [40, 40], [46, 46], [65, 90, 95, 95, 97, 122], [91, 91]];
  
  static final List<List<int>> _transitions6 = [[34, 34], [39, 39]];
  
  static final List<List<int>> _transitions7 = [[9, 10, 13, 13, 32, 32], [35, 35]];
  
  static final List<List<int>> _transitions8 = [[0, 122, 124, 1114111], [123, 123]];
  
  static final List<List<int>> _transitions9 = [[0, 91, 93, 1114111], [92, 92]];
  
  List<Map<int, List>> _cache;
  
  List<int> _cachePos;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<PegParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenLevel;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  PegParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;    
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {
    var map = _cache[id];
    if (map == null) {
      map = <int, List>{};
      _cache[id] = map;
    }
    map[start] = [result, _cursor, success];    
  }
  
  void _beginToken(int tokenId) {
    if (_tokenLevel++ == 0) {
      _token = tokenId;
      _tokenStart = _cursor;
    }  
  }
  
  void _endToken() {
    if (--_tokenLevel == 0) {
      _token = null;
      _tokenStart = null;
    }    
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated $name";
        _errors.add(new PegParserError(PegParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed $name";
        _errors.add(new PegParserError(PegParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(name);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {  
      _cacheable[id] = true;  
      return null;
    }
    var map = _cache[id];
    if (map == null) {
      return null;
    }
    var data = map[_cursor];
    if (data == null) {
      return null;
    }
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_ACTION() {
    // LEXEME
    // ACTION <- '{' ACTION_BODY* '}' SPACING
    var $$;
    // => '{' ACTION_BODY* '}' SPACING # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' ACTION_BODY* '}' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => ACTION_BODY*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => ACTION_BODY
            $$ = _parse_ACTION_BODY();
            // <= ACTION_BODY
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= ACTION_BODY*
          if (!success) break;
          seq[1] = $$;
          // => '}'
          $$ = _matchChar(125, '}');
          // <= '}'
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '{'
            final $1 = seq[0];
            // ACTION_BODY*
            final $2 = seq[1];
            // '}'
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = $2.join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' ACTION_BODY* '}' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect5);
    }
    // <= '{' ACTION_BODY* '}' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_ACTION_BODY() {
    // MORPHEME
    // ACTION_BODY <- '{' ACTION_BODY* '}' / !'}' .
    var $$;
    _beginToken(1);  
    // => '{' ACTION_BODY* '}' / !'}' . # Choice
    switch (_getState(_transitions8)) {
      // [\u0000-z] [|-\u0010ffff]
      // EOF
      case 0:
      case 3:
        // => !'}' . # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !'}'
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => '}'
          $$ = _matchChar(125, '}');
          // <= '}'
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !'}'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !'}'
            final $1 = seq[0];
            // .
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !'}' . # Sequence
        break;
      // [{]
      case 1:
        while (true) {
          // => '{' ACTION_BODY* '}' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '{'
            $$ = '{';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '{'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => ACTION_BODY*
            var testing1 = _testing; 
            for (var reps = []; ; ) {
              _testing = _cursor;
              // => ACTION_BODY
              $$ = _parse_ACTION_BODY();
              // <= ACTION_BODY
              if (success) {  
                reps.add($$);
              } else {
                success = true;
                _testing = testing1;
                $$ = reps;
                break; 
              }
            }
            // <= ACTION_BODY*
            if (!success) break;
            seq[1] = $$;
            // => '}'
            $$ = _matchChar(125, '}');
            // <= '}'
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // '{'
              final $1 = seq[0];
              // ACTION_BODY*
              final $2 = seq[1];
              // '}'
              final $3 = seq[2];
              final $start = startPos1;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos1;
          // <= '{' ACTION_BODY* '}' # Sequence
          if (success) break;
          // => !'}' . # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => !'}'
            var ch4 = _ch, pos4 = _cursor, testing2 = _testing; 
            _testing = _inputLen + 1;
            // => '}'
            $$ = _matchChar(125, '}');
            // <= '}'
            _ch = ch4;
            _cursor = pos4; 
            _testing = testing2;
            $$ = null;
            success = !success;
            // <= !'}'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => .
            $$ = _matchAny();
            // <= .
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // !'}'
              final $1 = seq[0];
              // .
              final $2 = seq[1];
              final $start = startPos2;
              $$ = _text();
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos2;
          // <= !'}' . # Sequence
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ACTION_BODY
      _failure(_expect23);
    }
    // <= '{' ACTION_BODY* '}' / !'}' . # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_AND() {
    // LEXEME
    // AND <- '&' SPACING
    var $$;
    // => '&' SPACING # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&'
          $$ = '&';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '&'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&'
      _failure(_expect6);
    }
    // <= '&' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_CHAR() {
    // MORPHEME
    // CHAR <- '\\' ["'\-\[-\]nrt] / HEX_NUMBER / !'\\' !EOL .
    var $$;
    _beginToken(2);  
    // => '\\' ["'\-\[-\]nrt] / HEX_NUMBER / !'\\' !EOL . # Choice
    switch (_getState(_transitions9)) {
      // [\u0000-[] []-\u0010ffff]
      // EOF
      case 0:
      case 3:
        // => !'\\' !EOL . # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !'\\'
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => '\\'
          $$ = _matchChar(92, '\\');
          // <= '\\'
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !'\\'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => !EOL
          var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          // => EOL
          $$ = _parse_EOL();
          // <= EOL
          _ch = ch2;
          _cursor = pos2; 
          _testing = testing1;
          $$ = null;
          success = !success;
          // <= !EOL
          if (!success) break;
          seq[1] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // !'\\'
            final $1 = seq[0];
            // !EOL
            final $2 = seq[1];
            // .
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _toCodePoint($3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !'\\' !EOL . # Sequence
        break;
      // [\\]
      case 1:
        while (true) {
          // => '\\' ["'\-\[-\]nrt] # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => ["'\-\[-\]nrt]
            $$ = _matchMapping(34, 116, _mapping0);
            // <= ["'\-\[-\]nrt]
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              // '\\'
              final $1 = seq[0];
              // ["'\-\[-\]nrt]
              final $2 = seq[1];
              final $start = startPos1;
              $$ = _escape($2.codeUnitAt(0));
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos1;
          // <= '\\' ["'\-\[-\]nrt] # Sequence
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => HEX_NUMBER
          $$ = _parse_HEX_NUMBER();
          // <= HEX_NUMBER
          _startPos = startPos2;
          if (success) break;
          // => !'\\' !EOL . # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => !'\\'
            var ch5 = _ch, pos5 = _cursor, testing2 = _testing; 
            _testing = _inputLen + 1;
            // => '\\'
            $$ = _matchChar(92, '\\');
            // <= '\\'
            _ch = ch5;
            _cursor = pos5; 
            _testing = testing2;
            $$ = null;
            success = !success;
            // <= !'\\'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => !EOL
            var ch6 = _ch, pos6 = _cursor, testing3 = _testing; 
            _testing = _inputLen + 1;
            // => EOL
            $$ = _parse_EOL();
            // <= EOL
            _ch = ch6;
            _cursor = pos6; 
            _testing = testing3;
            $$ = null;
            success = !success;
            // <= !EOL
            if (!success) break;
            seq[1] = $$;
            // => .
            $$ = _matchAny();
            // <= .
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // !'\\'
              final $1 = seq[0];
              // !EOL
              final $2 = seq[1];
              // .
              final $3 = seq[2];
              final $start = startPos3;
              $$ = _toCodePoint($3);
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos3;
          // <= !'\\' !EOL . # Sequence
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: CHAR
      _failure(_expect15);
    }
    // <= '\\' ["'\-\[-\]nrt] / HEX_NUMBER / !'\\' !EOL . # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_CLASS() {
    // LEXEME
    // CLASS <- '[' (!']' RANGE)* ']' SPACING
    var $$;
    // => '[' (!']' RANGE)* ']' SPACING # Choice
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      // [[]
      case 0:
        // => '[' (!']' RANGE)* ']' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '['
          $$ = '[';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '['
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => (!']' RANGE)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!']' RANGE) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !']' RANGE # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !']'
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
                  _testing = _inputLen + 1;
                  // => ']'
                  $$ = _matchChar(93, ']');
                  // <= ']'
                  _ch = ch2;
                  _cursor = pos2; 
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !']'
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => RANGE
                  $$ = _parse_RANGE();
                  // <= RANGE
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  if (success) {    
                    // !']'
                    final $1 = seq[0];
                    // RANGE
                    final $2 = seq[1];
                    final $start = startPos1;
                    $$ = $2;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !']' RANGE # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: RANGE
              _failure(_expect8);
            }
            // <= (!']' RANGE) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (!']' RANGE)*
          if (!success) break;
          seq[1] = $$;
          // => ']'
          $$ = _matchChar(93, ']');
          // <= ']'
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '['
            final $1 = seq[0];
            // (!']' RANGE)*
            final $2 = seq[1];
            // ']'
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new CharacterClassExpression($2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '[' (!']' RANGE)* ']' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '['
      _failure(_expect7);
    }
    // <= '[' (!']' RANGE)* ']' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_CLOSE() {
    // LEXEME
    // CLOSE <- ')' SPACING
    var $$;
    // => ')' SPACING # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ')'
      _failure(_expect9);
    }
    // <= ')' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_COMMENT() {
    // MORPHEME
    // COMMENT <- '#' (!EOL .)* EOL?
    var $$;
    _beginToken(3);  
    // => '#' (!EOL .)* EOL? # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => '#' (!EOL .)* EOL? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '#'
          $$ = '#';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '#'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => (!EOL .)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!EOL .) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !EOL . # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !EOL
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
                  _testing = _inputLen + 1;
                  // => EOL
                  $$ = _parse_EOL();
                  // <= EOL
                  _ch = ch2;
                  _cursor = pos2; 
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !EOL
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => .
                  $$ = _matchAny();
                  // <= .
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !EOL . # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: null
              _failure(_expect25);
            }
            // <= (!EOL .) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (!EOL .)*
          if (!success) break;
          seq[1] = $$;
          // => EOL?
          var testing2 = _testing;
          _testing = _cursor;
          // => EOL
          $$ = _parse_EOL();
          // <= EOL
          success = true; 
          _testing = testing2;
          // <= EOL?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '#' (!EOL .)* EOL? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '#'
      _failure(_expect24);
    }
    // <= '#' (!EOL .)* EOL? # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_DOT() {
    // LEXEME
    // DOT <- '.' SPACING
    var $$;
    // => '.' SPACING # Choice
    switch (_ch == 46 ? 0 : _ch == -1 ? 2 : 1) {
      // [.]
      case 0:
        // => '.' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '.'
          $$ = '.';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '.'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '.' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '.'
      _failure(_expect10);
    }
    // <= '.' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Definition() {
    // NONTERMINAL
    // Definition <- IDENTIFIER LEFTARROW Expression
    var $$;
    // => IDENTIFIER LEFTARROW Expression # Choice
    switch (_getState(_transitions0)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => IDENTIFIER LEFTARROW Expression # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => LEFTARROW
          $$ = _parse_LEFTARROW();
          // <= LEFTARROW
          if (!success) break;
          seq[1] = $$;
          // => Expression
          $$ = _parse_Expression();
          // <= Expression
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // IDENTIFIER
            final $1 = seq[0];
            // LEFTARROW
            final $2 = seq[1];
            // Expression
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new ProductionRule($1, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= IDENTIFIER LEFTARROW Expression # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect0);
    }
    // <= IDENTIFIER LEFTARROW Expression # Choice
    return $$;
  }
  
  dynamic _parse_EOF() {
    // LEXEME
    // EOF <- !.
    var $$;
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect11);
    }
    // <= !. # Choice
    return $$;
  }
  
  dynamic _parse_EOL() {
    // MORPHEME
    // EOL <- '\r\n' / [\n\r]
    var $$;
    _beginToken(4);  
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions10)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping1);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => '\r\n'
          $$ = _matchString(_strings3, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping1);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOL
      _failure(_expect26);
    }
    // <= '\r\n' / [\n\r] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_Expression() {
    // NONTERMINAL
    // Expression <- Sequence (SLASH Sequence)*
    var $$;          
    var pos = _cursor;    
    if(_cachePos[2] >= pos) {
      $$ = _getFromCache(2);
    } else {
      _cachePos[2] = pos;
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => Sequence (SLASH Sequence)* # Choice
    switch (_getState(_transitions1)) {
      // [!-\"] [&-(] [.] [A-[] [_] [a-z]
      case 0:
        // => Sequence (SLASH Sequence)* # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Sequence
          $$ = _parse_Sequence();
          // <= Sequence
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (SLASH Sequence)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (SLASH Sequence) # Choice
            switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
              // [/]
              case 0:
                // => SLASH Sequence # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => SLASH
                  $$ = _parse_SLASH();
                  // <= SLASH
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => Sequence
                  $$ = _parse_Sequence();
                  // <= Sequence
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= SLASH Sequence # Sequence
                break;
              // No matches
              // EOF
              case 1:
              case 2:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: '/'
              _failure(_expect2);
            }
            // <= (SLASH Sequence) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (SLASH Sequence)*
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // Sequence
            final $1 = seq[0];
            // (SLASH Sequence)*
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new OrderedChoiceExpression(_list($1, $2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Sequence (SLASH Sequence)* # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, '(', LITERAL, '[', '.'
      _failure(_expect1);
    }
    // <= Sequence (SLASH Sequence)* # Choice
    if (_cacheable[2]) {
      _addToCache($$, pos, 2);
    }  
    return $$;
  }
  
  dynamic _parse_GLOBALS() {
    // LEXEME
    // GLOBALS <- '%{' GLOBALS_BODY* '}%' SPACING
    var $$;
    // => '%{' GLOBALS_BODY* '}%' SPACING # Choice
    switch (_ch == 37 ? 0 : _ch == -1 ? 2 : 1) {
      // [%]
      case 0:
        // => '%{' GLOBALS_BODY* '}%' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '%{'
          $$ = _matchString(_strings0, '%{');
          // <= '%{'
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => GLOBALS_BODY*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => GLOBALS_BODY
            $$ = _parse_GLOBALS_BODY();
            // <= GLOBALS_BODY
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= GLOBALS_BODY*
          if (!success) break;
          seq[1] = $$;
          // => '}%'
          $$ = _matchString(_strings1, '}%');
          // <= '}%'
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '%{'
            final $1 = seq[0];
            // GLOBALS_BODY*
            final $2 = seq[1];
            // '}%'
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = $2.join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '%{' GLOBALS_BODY* '}%' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '%{'
      _failure(_expect12);
    }
    // <= '%{' GLOBALS_BODY* '}%' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_GLOBALS_BODY() {
    // MORPHEME
    // GLOBALS_BODY <- !'}%' .
    var $$;
    _beginToken(5);  
    // => !'}%' . # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => !'}%' . # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => !'}%'
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => '}%'
          $$ = _matchString(_strings1, '}%');
          // <= '}%'
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !'}%'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => .
          $$ = _matchAny();
          // <= .
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // !'}%'
            final $1 = seq[0];
            // .
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _text();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= !'}%' . # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: GLOBALS_BODY
      _failure(_expect27);
    }
    // <= !'}%' . # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_HEX_NUMBER() {
    // MORPHEME
    // HEX_NUMBER <- [\\] 'u' [0-9A-Fa-f]+
    var $$;
    _beginToken(6);  
    // => [\\] 'u' [0-9A-Fa-f]+ # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => [\\] 'u' [0-9A-Fa-f]+ # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => [\\]
          $$ = '\\';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= [\\]
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => 'u'
          $$ = _matchChar(117, 'u');
          // <= 'u'
          if (!success) break;
          seq[1] = $$;
          // => [0-9A-Fa-f]+
          var testing0;
          for (var first = true, reps; ;) {  
            // => [0-9A-Fa-f]  
            $$ = _matchMapping(48, 102, _mapping2);  
            // <= [0-9A-Fa-f]  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= [0-9A-Fa-f]+
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // [\\]
            final $1 = seq[0];
            // 'u'
            final $2 = seq[1];
            // [0-9A-Fa-f]+
            final $3 = seq[2];
            final $start = startPos0;
            $$ = int.parse($3.join(), radix: 16);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= [\\] 'u' [0-9A-Fa-f]+ # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: HEX_NUMBER
      _failure(_expect28);
    }
    // <= [\\] 'u' [0-9A-Fa-f]+ # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_IDENTIFIER() {
    // LEXEME
    // IDENTIFIER <- IDENT_START IDENT_CONT* SPACING
    var $$;          
    var pos = _cursor;    
    if(_cachePos[14] >= pos) {
      $$ = _getFromCache(14);
    } else {
      _cachePos[14] = pos;
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => IDENT_START IDENT_CONT* SPACING # Choice
    switch (_getState(_transitions0)) {
      // [A-Z] [_] [a-z]
      case 0:
        // => IDENT_START IDENT_CONT* SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => IDENT_START
          $$ = _parse_IDENT_START();
          // <= IDENT_START
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => IDENT_CONT*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => IDENT_CONT
            $$ = _parse_IDENT_CONT();
            // <= IDENT_CONT
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= IDENT_CONT*
          if (!success) break;
          seq[1] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // IDENT_START
            final $1 = seq[0];
            // IDENT_CONT*
            final $2 = seq[1];
            // SPACING
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _flatten([$1, $2]).join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= IDENT_START IDENT_CONT* SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect0);
    }
    // <= IDENT_START IDENT_CONT* SPACING # Choice
    if (_cacheable[14]) {
      _addToCache($$, pos, 14);
    }  
    return $$;
  }
  
  dynamic _parse_IDENT_CONT() {
    // MORPHEME
    // IDENT_CONT <- IDENT_START / [0-9]
    var $$;
    _beginToken(7);  
    // => IDENT_START / [0-9] # Choice
    switch (_getState(_transitions11)) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // [A-Z] [_] [a-z]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => IDENT_START
        $$ = _parse_IDENT_START();
        // <= IDENT_START
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT_CONT
      _failure(_expect29);
    }
    // <= IDENT_START / [0-9] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_IDENT_START() {
    // MORPHEME
    // IDENT_START <- [A-Z_a-z]
    var $$;
    _beginToken(8);  
    // => [A-Z_a-z] # Choice
    switch (_getState(_transitions0)) {
      // [A-Z] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [A-Z_a-z]
        $$ = _matchMapping(65, 122, _mapping3);
        // <= [A-Z_a-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENT_START
      _failure(_expect30);
    }
    // <= [A-Z_a-z] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_LEFTARROW() {
    // LEXEME
    // LEFTARROW <- '<-' SPACING
    var $$;          
    var pos = _cursor;    
    if(_cachePos[15] >= pos) {
      $$ = _getFromCache(15);
    } else {
      _cachePos[15] = pos;
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => '<-' SPACING # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<-' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<-'
          $$ = _matchString(_strings2, '<-');
          // <= '<-'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<-' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<-'
      _failure(_expect13);
    }
    // <= '<-' SPACING # Choice
    if (_cacheable[15]) {
      _addToCache($$, pos, 15);
    }  
    return $$;
  }
  
  dynamic _parse_LITERAL() {
    // LEXEME
    // LITERAL <- '\'' (!'\'' CHAR)* '\'' SPACING / '"' (!'"' CHAR)* '"' SPACING
    var $$;
    // => '\'' (!'\'' CHAR)* '\'' SPACING / '"' (!'"' CHAR)* '"' SPACING # Choice
    switch (_getState(_transitions6)) {
      // [\"]
      case 0:
        // => '"' (!'"' CHAR)* '"' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '"'
          $$ = '\"';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '"'
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => (!'"' CHAR)*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!'"' CHAR) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !'"' CHAR # Sequence
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !'"'
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing; 
                  _testing = _inputLen + 1;
                  // => '"'
                  $$ = _matchChar(34, '\"');
                  // <= '"'
                  _ch = ch2;
                  _cursor = pos2; 
                  _testing = testing1;
                  $$ = null;
                  success = !success;
                  // <= !'"'
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => CHAR
                  $$ = _parse_CHAR();
                  // <= CHAR
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  if (success) {    
                    // !'"'
                    final $1 = seq[0];
                    // CHAR
                    final $2 = seq[1];
                    final $start = startPos1;
                    $$ = $2;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                // <= !'"' CHAR # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: CHAR
              _failure(_expect15);
            }
            // <= (!'"' CHAR) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= (!'"' CHAR)*
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '"'
            final $1 = seq[0];
            // (!'"' CHAR)*
            final $2 = seq[1];
            // '"'
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new LiteralExpression(new String.fromCharCodes($2));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '"' (!'"' CHAR)* '"' SPACING # Sequence
        break;
      // [\']
      case 1:
        // => '\'' (!'\'' CHAR)* '\'' SPACING # Sequence
        var ch3 = _ch, pos3 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\''
          $$ = '\'';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '\''
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => (!'\'' CHAR)*
          var testing2 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => (!'\'' CHAR) # Choice
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              // [\u0000-\u0010ffff]
              // EOF
              case 0:
              case 2:
                // => !'\'' CHAR # Sequence
                var ch4 = _ch, pos4 = _cursor, startPos3 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  // => !'\''
                  var ch5 = _ch, pos5 = _cursor, testing3 = _testing; 
                  _testing = _inputLen + 1;
                  // => '\''
                  $$ = _matchChar(39, '\'');
                  // <= '\''
                  _ch = ch5;
                  _cursor = pos5; 
                  _testing = testing3;
                  $$ = null;
                  success = !success;
                  // <= !'\''
                  if (!success) break;
                  var seq = new List(2)..[0] = $$;
                  // => CHAR
                  $$ = _parse_CHAR();
                  // <= CHAR
                  if (!success) break;
                  seq[1] = $$;
                  $$ = seq;
                  if (success) {    
                    // !'\''
                    final $1 = seq[0];
                    // CHAR
                    final $2 = seq[1];
                    final $start = startPos3;
                    $$ = $2;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch4;
                  _cursor = pos4;
                }
                _startPos = startPos3;
                // <= !'\'' CHAR # Sequence
                break;
              // No matches
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              // Expected: CHAR
              _failure(_expect15);
            }
            // <= (!'\'' CHAR) # Choice
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing2;
              $$ = reps;
              break; 
            }
          }
          // <= (!'\'' CHAR)*
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '\''
            final $1 = seq[0];
            // (!'\'' CHAR)*
            final $2 = seq[1];
            // '\''
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos2;
            $$ = new LiteralExpression(new String.fromCharCodes($2));
          }
          break;
        }
        if (!success) {
          _ch = ch3;
          _cursor = pos3;
        }
        _startPos = startPos2;
        // <= '\'' (!'\'' CHAR)* '\'' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: LITERAL
      _failure(_expect14);
    }
    // <= '\'' (!'\'' CHAR)* '\'' SPACING / '"' (!'"' CHAR)* '"' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_MEMBERS() {
    // LEXEME
    // MEMBERS <- '{' ACTION_BODY* '}' SPACING
    var $$;
    // => '{' ACTION_BODY* '}' SPACING # Choice
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      // [{]
      case 0:
        // => '{' ACTION_BODY* '}' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '{'
          $$ = '{';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '{'
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => ACTION_BODY*
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            // => ACTION_BODY
            $$ = _parse_ACTION_BODY();
            // <= ACTION_BODY
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          // <= ACTION_BODY*
          if (!success) break;
          seq[1] = $$;
          // => '}'
          $$ = _matchChar(125, '}');
          // <= '}'
          if (!success) break;
          seq[2] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            // '{'
            final $1 = seq[0];
            // ACTION_BODY*
            final $2 = seq[1];
            // '}'
            final $3 = seq[2];
            // SPACING
            final $4 = seq[3];
            final $start = startPos0;
            $$ = $2.join();
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '{' ACTION_BODY* '}' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '{'
      _failure(_expect5);
    }
    // <= '{' ACTION_BODY* '}' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_NOT() {
    // LEXEME
    // NOT <- '!' SPACING
    var $$;
    // => '!' SPACING # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!'
          $$ = '!';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '!'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '!'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '!'
      _failure(_expect16);
    }
    // <= '!' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_OPEN() {
    // LEXEME
    // OPEN <- '(' SPACING
    var $$;
    // => '(' SPACING # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect17);
    }
    // <= '(' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_PLUS() {
    // LEXEME
    // PLUS <- '+' SPACING
    var $$;
    // => '+' SPACING # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '+'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '+'
      _failure(_expect18);
    }
    // <= '+' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Prefix() {
    // NONTERMINAL
    // Prefix <- (AND / NOT)? Suffix ACTION?
    var $$;
    // => (AND / NOT)? Suffix ACTION? # Choice
    switch (_getState(_transitions1)) {
      // [!-\"] [&-(] [.] [A-[] [_] [a-z]
      case 0:
        // => (AND / NOT)? Suffix ACTION? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => (AND / NOT)?
          var testing0 = _testing;
          _testing = _cursor;
          // => (AND / NOT) # Choice
          switch (_getState(_transitions2)) {
            // [!]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => NOT
              $$ = _parse_NOT();
              // <= NOT
              _startPos = startPos1;
              break;
            // [&]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => AND
              $$ = _parse_AND();
              // <= AND
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: '&', '!'
            _failure(_expect3);
          }
          // <= (AND / NOT) # Choice
          success = true; 
          _testing = testing0;
          // <= (AND / NOT)?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Suffix
          $$ = _parse_Suffix();
          // <= Suffix
          if (!success) break;
          seq[1] = $$;
          // => ACTION?
          var testing1 = _testing;
          _testing = _cursor;
          // => ACTION
          $$ = _parse_ACTION();
          // <= ACTION
          success = true; 
          _testing = testing1;
          // <= ACTION?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // (AND / NOT)?
            final $1 = seq[0];
            // Suffix
            final $2 = seq[1];
            // ACTION?
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _prefix($1, $2, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= (AND / NOT)? Suffix ACTION? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, '(', LITERAL, '[', '.'
      _failure(_expect1);
    }
    // <= (AND / NOT)? Suffix ACTION? # Choice
    return $$;
  }
  
  dynamic _parse_Primary() {
    // NONTERMINAL
    // Primary <- IDENTIFIER !LEFTARROW / OPEN Expression CLOSE / LITERAL / CLASS / DOT
    var $$;
    // => IDENTIFIER !LEFTARROW / OPEN Expression CLOSE / LITERAL / CLASS / DOT # Choice
    switch (_getState(_transitions5)) {
      // [\"] [\']
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => LITERAL
        $$ = _parse_LITERAL();
        // <= LITERAL
        _startPos = startPos0;
        break;
      // [(]
      case 1:
        // => OPEN Expression CLOSE # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => OPEN
          $$ = _parse_OPEN();
          // <= OPEN
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => Expression
          $$ = _parse_Expression();
          // <= Expression
          if (!success) break;
          seq[1] = $$;
          // => CLOSE
          $$ = _parse_CLOSE();
          // <= CLOSE
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            // OPEN
            final $1 = seq[0];
            // Expression
            final $2 = seq[1];
            // CLOSE
            final $3 = seq[2];
            final $start = startPos1;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos1;
        // <= OPEN Expression CLOSE # Sequence
        break;
      // [.]
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        // => DOT
        $$ = _parse_DOT();
        // <= DOT
        if (success) {    
          // DOT
          final $1 = $$;
          final $start = startPos2;
          $$ = new AnyCharacterExpression();
        }
        _startPos = startPos2;
        break;
      // [A-Z] [_] [a-z]
      case 3:
        // => IDENTIFIER !LEFTARROW # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos3 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => IDENTIFIER
          $$ = _parse_IDENTIFIER();
          // <= IDENTIFIER
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => !LEFTARROW
          var ch2 = _ch, pos2 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          // => LEFTARROW
          $$ = _parse_LEFTARROW();
          // <= LEFTARROW
          _ch = ch2;
          _cursor = pos2; 
          _testing = testing0;
          $$ = null;
          success = !success;
          // <= !LEFTARROW
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // IDENTIFIER
            final $1 = seq[0];
            // !LEFTARROW
            final $2 = seq[1];
            final $start = startPos3;
            $$ = new RuleExpression($1);
          }
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos3;
        // <= IDENTIFIER !LEFTARROW # Sequence
        break;
      // [[]
      case 4:
        var startPos4 = _startPos;
        _startPos = _cursor;
        // => CLASS
        $$ = _parse_CLASS();
        // <= CLASS
        _startPos = startPos4;
        break;
      // No matches
      // EOF
      case 5:
      case 6:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, '(', LITERAL, '[', '.'
      _failure(_expect1);
    }
    // <= IDENTIFIER !LEFTARROW / OPEN Expression CLOSE / LITERAL / CLASS / DOT # Choice
    return $$;
  }
  
  dynamic _parse_QUESTION() {
    // LEXEME
    // QUESTION <- '?' SPACING
    var $$;
    // => '?' SPACING # Choice
    switch (_ch == 63 ? 0 : _ch == -1 ? 2 : 1) {
      // [?]
      case 0:
        // => '?' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '?'
          $$ = '?';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '?'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '?'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '?' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '?'
      _failure(_expect19);
    }
    // <= '?' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_RANGE() {
    // MORPHEME
    // RANGE <- CHAR '-' CHAR / CHAR
    var $$;
    _beginToken(9);  
    // => CHAR '-' CHAR / CHAR # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        while (true) {
          // => CHAR '-' CHAR # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => CHAR
            $$ = _parse_CHAR();
            // <= CHAR
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => '-'
            $$ = _matchChar(45, '-');
            // <= '-'
            if (!success) break;
            seq[1] = $$;
            // => CHAR
            $$ = _parse_CHAR();
            // <= CHAR
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              // CHAR
              final $1 = seq[0];
              // '-'
              final $2 = seq[1];
              // CHAR
              final $3 = seq[2];
              final $start = startPos0;
              $$ = [$1, $3];
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= CHAR '-' CHAR # Sequence
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          // => CHAR
          $$ = _parse_CHAR();
          // <= CHAR
          if (success) {    
            // CHAR
            final $1 = $$;
            final $start = startPos1;
            $$ = [$1, $1];
          }
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: RANGE
      _failure(_expect8);
    }
    // <= CHAR '-' CHAR / CHAR # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_SLASH() {
    // LEXEME
    // SLASH <- '/' SPACING
    var $$;
    // => '/' SPACING # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '/' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '/'
          $$ = '/';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '/'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '/' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '/'
      _failure(_expect2);
    }
    // <= '/' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_SPACE() {
    // MORPHEME
    // SPACE <- [\t ] / EOL
    var $$;
    _beginToken(10);  
    // => [\t ] / EOL # Choice
    switch (_getState(_transitions12)) {
      // [\t] [ ]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => [\t ]
        $$ = _matchMapping(9, 32, _mapping4);
        // <= [\t ]
        _startPos = startPos0;
        break;
      // [\n] [\r]
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        // => EOL
        $$ = _parse_EOL();
        // <= EOL
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SPACE
      _failure(_expect31);
    }
    // <= [\t ] / EOL # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_SPACING() {
    // LEXEME & MORPHEME
    // SPACING <- (SPACE / COMMENT)*
    var $$;
    _beginToken(0);  
    // => (SPACE / COMMENT)* # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => (SPACE / COMMENT)*
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          // => (SPACE / COMMENT) # Choice
          switch (_getState(_transitions7)) {
            // [\t-\n] [\r] [ ]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => SPACE
              $$ = _parse_SPACE();
              // <= SPACE
              _startPos = startPos1;
              break;
            // [#]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => COMMENT
              $$ = _parse_COMMENT();
              // <= COMMENT
              _startPos = startPos2;
              break;
            // No matches
            // EOF
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: SPACE, '#'
            _failure(_expect21);
          }
          // <= (SPACE / COMMENT) # Choice
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        // <= (SPACE / COMMENT)*
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: SPACING
      _failure(_expect20);
    }
    // <= (SPACE / COMMENT)* # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_STAR() {
    // LEXEME
    // STAR <- '*' SPACING
    var $$;
    // => '*' SPACING # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' SPACING # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // '*'
            final $1 = seq[0];
            // SPACING
            final $2 = seq[1];
            final $start = startPos0;
            $$ = $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' SPACING # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect22);
    }
    // <= '*' SPACING # Choice
    return $$;
  }
  
  dynamic _parse_Sequence() {
    // NONTERMINAL
    // Sequence <- Prefix+
    var $$;          
    var pos = _cursor;    
    if(_cachePos[3] >= pos) {
      $$ = _getFromCache(3);
    } else {
      _cachePos[3] = pos;
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => Prefix+ # Choice
    switch (_getState(_transitions1)) {
      // [!-\"] [&-(] [.] [A-[] [_] [a-z]
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        // => Prefix+
        var testing0;
        for (var first = true, reps; ;) {  
          // => Prefix  
          $$ = _parse_Prefix();  
          // <= Prefix  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= Prefix+
        if (success) {    
          // Prefix+
          final $1 = $$;
          final $start = startPos0;
          $$ = new SequenceExpression($1);
        }
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, '(', LITERAL, '[', '.'
      _failure(_expect1);
    }
    // <= Prefix+ # Choice
    if (_cacheable[3]) {
      _addToCache($$, pos, 3);
    }  
    return $$;
  }
  
  dynamic _parse_Suffix() {
    // NONTERMINAL
    // Suffix <- Primary (QUESTION / STAR / PLUS)?
    var $$;
    // => Primary (QUESTION / STAR / PLUS)? # Choice
    switch (_getState(_transitions3)) {
      // [\"] [\'-(] [.] [A-[] [_] [a-z]
      case 0:
        // => Primary (QUESTION / STAR / PLUS)? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => Primary
          $$ = _parse_Primary();
          // <= Primary
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => (QUESTION / STAR / PLUS)?
          var testing0 = _testing;
          _testing = _cursor;
          // => (QUESTION / STAR / PLUS) # Choice
          switch (_getState(_transitions4)) {
            // [*]
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              // => STAR
              $$ = _parse_STAR();
              // <= STAR
              _startPos = startPos1;
              break;
            // [+]
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              // => PLUS
              $$ = _parse_PLUS();
              // <= PLUS
              _startPos = startPos2;
              break;
            // [?]
            case 2:
              var startPos3 = _startPos;
              _startPos = _cursor;
              // => QUESTION
              $$ = _parse_QUESTION();
              // <= QUESTION
              _startPos = startPos3;
              break;
            // No matches
            // EOF
            case 3:
            case 4:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: '?', '*', '+'
            _failure(_expect4);
          }
          // <= (QUESTION / STAR / PLUS) # Choice
          success = true; 
          _testing = testing0;
          // <= (QUESTION / STAR / PLUS)?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            // Primary
            final $1 = seq[0];
            // (QUESTION / STAR / PLUS)?
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _suffix($2, $1);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= Primary (QUESTION / STAR / PLUS)? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER, '(', LITERAL, '[', '.'
      _failure(_expect1);
    }
    // <= Primary (QUESTION / STAR / PLUS)? # Choice
    return $$;
  }
  
  String _text([int offset = 0]) {
    return new String.fromCharCodes(_input.sublist(_startPos + offset, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<PegParserError> errors() {
    if (success) {
      return <PegParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <PegParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<PegParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new PegParserError(PegParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new PegParserError(PegParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_Grammar() {
    // NONTERMINAL
    // Grammar <- SPACING? GLOBALS? MEMBERS? Definition+ EOF
    var $$;
    // => SPACING? GLOBALS? MEMBERS? Definition+ EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        // => SPACING? GLOBALS? MEMBERS? Definition+ EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => SPACING?
          var testing0 = _testing;
          _testing = _cursor;
          // => SPACING
          $$ = _parse_SPACING();
          // <= SPACING
          success = true; 
          _testing = testing0;
          // <= SPACING?
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => GLOBALS?
          var testing1 = _testing;
          _testing = _cursor;
          // => GLOBALS
          $$ = _parse_GLOBALS();
          // <= GLOBALS
          success = true; 
          _testing = testing1;
          // <= GLOBALS?
          if (!success) break;
          seq[1] = $$;
          // => MEMBERS?
          var testing2 = _testing;
          _testing = _cursor;
          // => MEMBERS
          $$ = _parse_MEMBERS();
          // <= MEMBERS
          success = true; 
          _testing = testing2;
          // <= MEMBERS?
          if (!success) break;
          seq[2] = $$;
          // => Definition+
          var testing3;
          for (var first = true, reps; ;) {  
            // => Definition  
            $$ = _parse_Definition();  
            // <= Definition  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing3 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing3;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          // <= Definition+
          if (!success) break;
          seq[3] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {    
            // SPACING?
            final $1 = seq[0];
            // GLOBALS?
            final $2 = seq[1];
            // MEMBERS?
            final $3 = seq[2];
            // Definition+
            final $4 = seq[3];
            // EOF
            final $5 = seq[4];
            final $start = startPos0;
            $$ = new Grammar($4, $2, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= SPACING? GLOBALS? MEMBERS? Definition+ EOF # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: IDENTIFIER
      _failure(_expect0);
    }
    // <= SPACING? GLOBALS? MEMBERS? Definition+ EOF # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List<Map<int, List>>(36);
    _cachePos = new List<int>.filled(36, -1);  
    _cacheable = new List<bool>.filled(36, false);
    _ch = -1;
    _errors = <PegParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenLevel = 0;
    _tokenStart = null;  
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class PegParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  PegParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is PegParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

