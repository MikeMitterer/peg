// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

part of preprocessor.internal.parser;

class PParser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>["EOF"];
  
  static final List<String> _expect1 = <String>["#if", "#ifdef", "#ifndef"];
  
  static final List<String> _expect10 = <String>["\'0\'"];
  
  static final List<String> _expect100 = <String>["long_suffix"];
  
  static final List<String> _expect101 = <String>["nondigit"];
  
  static final List<String> _expect102 = <String>["spaces"];
  
  static final List<String> _expect103 = <String>["unsigned_suffix"];
  
  static final List<String> _expect11 = <String>["octal_constant1"];
  
  static final List<String> _expect12 = <String>["hexadecimal_constant"];
  
  static final List<String> _expect13 = <String>["hexadecimal_constant1"];
  
  static final List<String> _expect14 = <String>["character_constant"];
  
  static final List<String> _expect15 = <String>["c_char_sequence"];
  
  static final List<String> _expect16 = <String>["c_char"];
  
  static final List<String> _expect17 = <String>[null];
  
  static final List<String> _expect18 = <String>["escape_sequence"];
  
  static final List<String> _expect19 = <String>["\'\\x\'"];
  
  static final List<String> _expect2 = <String>["\'(\'", "constant", "identifier", "string_literal", "unary_operator"];
  
  static final List<String> _expect20 = <String>["hexadecimal_escape_sequence1"];
  
  static final List<String> _expect21 = <String>["string_literal"];
  
  static final List<String> _expect22 = <String>["s_char_sequence"];
  
  static final List<String> _expect23 = <String>["s_char"];
  
  static final List<String> _expect24 = <String>[null, "\',\'"];
  
  static final List<String> _expect25 = <String>[null, "multiplicative_operator"];
  
  static final List<String> _expect26 = <String>[null, "\'+\'"];
  
  static final List<String> _expect27 = <String>[null, "\'<<\'"];
  
  static final List<String> _expect28 = <String>[null, "relational_operator"];
  
  static final List<String> _expect29 = <String>[null, "\'!=\'", "\'==\'"];
  
  static final List<String> _expect3 = <String>["\'(\'", "constant", "identifier", "string_literal"];
  
  static final List<String> _expect30 = <String>[null, "\'&\'"];
  
  static final List<String> _expect31 = <String>[null, "\'^\'"];
  
  static final List<String> _expect32 = <String>[null, "\'|\'"];
  
  static final List<String> _expect33 = <String>[null, "\'&&\'"];
  
  static final List<String> _expect34 = <String>[null, "\'||\'"];
  
  static final List<String> _expect35 = <String>["#elif"];
  
  static final List<String> _expect36 = <String>["#else"];
  
  static final List<String> _expect37 = <String>["control_line"];
  
  static final List<String> _expect38 = <String>["replacement_list"];
  
  static final List<String> _expect39 = <String>["pp_tokens"];
  
  static final List<String> _expect4 = <String>["identifier"];
  
  static final List<String> _expect40 = <String>["preprocessing_token"];
  
  static final List<String> _expect41 = <String>["pp_number"];
  
  static final List<String> _expect42 = <String>["pp_number1"];
  
  static final List<String> _expect43 = <String>["\'#undef\'"];
  
  static final List<String> _expect44 = <String>["\'#error\'"];
  
  static final List<String> _expect45 = <String>["text_line"];
  
  static final List<String> _expect46 = <String>["non_directive"];
  
  static final List<String> _expect47 = <String>["\'&\'"];
  
  static final List<String> _expect48 = <String>["\'&&\'"];
  
  static final List<String> _expect49 = <String>["\',\'"];
  
  static final List<String> _expect5 = <String>["identifier1"];
  
  static final List<String> _expect50 = <String>["\'==\'"];
  
  static final List<String> _expect51 = <String>["\'!=\'"];
  
  static final List<String> _expect52 = <String>["\'|\'"];
  
  static final List<String> _expect53 = <String>["\'||\'"];
  
  static final List<String> _expect54 = <String>["\'?\'"];
  
  static final List<String> _expect55 = <String>["\':\'"];
  
  static final List<String> _expect56 = <String>["\'^\'"];
  
  static final List<String> _expect57 = <String>["\'+\'"];
  
  static final List<String> _expect58 = <String>["assignment_operator"];
  
  static final List<String> _expect59 = <String>["digit"];
  
  static final List<String> _expect6 = <String>["constant"];
  
  static final List<String> _expect60 = <String>["\'#endif\'"];
  
  static final List<String> _expect61 = <String>["floating_constant"];
  
  static final List<String> _expect62 = <String>["hexadecimal_digit"];
  
  static final List<String> _expect63 = <String>["hexadecimal_prefix"];
  
  static final List<String> _expect64 = <String>["identifier_nondigit"];
  
  static final List<String> _expect65 = <String>["integer_suffix"];
  
  static final List<String> _expect66 = <String>["\'(\'"];
  
  static final List<String> _expect67 = <String>["multiplicative_operator"];
  
  static final List<String> _expect68 = <String>["new_line"];
  
  static final List<String> _expect69 = <String>["nonzero_digit"];
  
  static final List<String> _expect7 = <String>["integer_constant"];
  
  static final List<String> _expect70 = <String>["octal_digit"];
  
  static final List<String> _expect71 = <String>["\'\\\'"];
  
  static final List<String> _expect72 = <String>["punctuator"];
  
  static final List<String> _expect73 = <String>["relational_operator"];
  
  static final List<String> _expect74 = <String>["\')\'"];
  
  static final List<String> _expect75 = <String>["\'<<\'"];
  
  static final List<String> _expect76 = <String>["sign"];
  
  static final List<String> _expect77 = <String>["simple_escape_sequence"];
  
  static final List<String> _expect78 = <String>["unary_operator"];
  
  static final List<String> _expect79 = <String>["universal_character_name"];
  
  static final List<String> _expect8 = <String>["decimal_constant"];
  
  static final List<String> _expect80 = <String>["\'*\'"];
  
  static final List<String> _expect81 = <String>["\'!\'"];
  
  static final List<String> _expect82 = <String>["\'>\'"];
  
  static final List<String> _expect83 = <String>["\'>=\'"];
  
  static final List<String> _expect84 = <String>["\'<\'"];
  
  static final List<String> _expect85 = <String>["\'<=\'"];
  
  static final List<String> _expect86 = <String>["\'%\'"];
  
  static final List<String> _expect87 = <String>["\'/\'"];
  
  static final List<String> _expect88 = <String>["\'~\'"];
  
  static final List<String> _expect89 = <String>["binary_exponent_part"];
  
  static final List<String> _expect9 = <String>["decimal_constant1"];
  
  static final List<String> _expect90 = <String>["decimal_floating_constant"];
  
  static final List<String> _expect91 = <String>["digit_sequence"];
  
  static final List<String> _expect92 = <String>["exponent_part"];
  
  static final List<String> _expect93 = <String>["floating_suffix"];
  
  static final List<String> _expect94 = <String>["fractional_constant"];
  
  static final List<String> _expect95 = <String>["hex_quad"];
  
  static final List<String> _expect96 = <String>["hexadecimal_digit_sequence"];
  
  static final List<String> _expect97 = <String>["hexadecimal_floating_constant"];
  
  static final List<String> _expect98 = <String>["hexadecimal_fractional_constant"];
  
  static final List<String> _expect99 = <String>["long_long_suffix"];
  
  static final List<bool> _lookahead = _unmap([0x7f800009, 0x7f7fffff, 0x7e3fffff, 0x21dfffff, 0xc, 0x0, 0x47000000, 0x7c07fedb, 0x785fffff, 0x763fffff, 0x3f003fd, 0x1400000, 0xe800000, 0x780ffd86, 0x70bfffff, 0x31ffffff, 0x38005, 0x40000, 0x860000, 0x10000, 0x1184000, 0x400006a2, 0x1ffffff, 0x7ffffff, 0x7fff8000, 0x7fff0bff, 0x3ff40fff, 0x220000, 0x7ec00000, 0x400000f, 0x18000000, 0x20000000, 0x40000000, 0x7ffffffd, 0x61fffff, 0x0, 0x100c0, 0x1060100, 0x6080000, 0x0, 0x600004e, 0x21]);
  
  // '\n', '\r', '\'', '\\'
  static final List<bool> _mapping0 = _unmap([0x20000009, 0x0, 0x100000]);
  
  // '\n', '\r', '\"', '\\'
  static final List<bool> _mapping1 = _unmap([0x1000009, 0x0, 0x100000]);
  
  // '\t', '\n', '\r', ' '
  static final List<bool> _mapping10 = _unmap([0x800013]);
  
  // 'U', 'u'
  static final List<bool> _mapping11 = _unmap([0x1, 0x2]);
  
  // '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'f'
  static final List<bool> _mapping2 = _unmap([0x7fffffff, 0x87ffff]);
  
  // '\n', '\r'
  static final List<bool> _mapping3 = _unmap([0x9]);
  
  // '!', '#', '\$', '%', '&', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', '~'
  static final List<bool> _mapping4 = _unmap([0x7e007fbd, 0x28000000, 0x50000000, 0x1]);
  
  // '+', '-'
  static final List<bool> _mapping5 = _unmap([0x5]);
  
  // '\"', '\'', '?', '\\', 'a', 'b', 'f', 'n', 'r', 't', 'v'
  static final List<bool> _mapping6 = _unmap([0x20000021, 0x8000000, 0x544046]);
  
  // 'F', 'L', 'f', 'l'
  static final List<bool> _mapping7 = _unmap([0x41, 0x82]);
  
  // 'L', 'l'
  static final List<bool> _mapping8 = _unmap([0x1, 0x2]);
  
  // '-', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  static final List<bool> _mapping9 = _unmap([0x7ff00001, 0x7fe07fff, 0xffff]);
  
  // '#if'
  static final List<int> _strings0 = <int>[35, 105, 102];
  
  // '#ifdef'
  static final List<int> _strings1 = <int>[35, 105, 102, 100, 101, 102];
  
  // '#error'
  static final List<int> _strings10 = <int>[35, 101, 114, 114, 111, 114];
  
  // '&&'
  static final List<int> _strings11 = <int>[38, 38];
  
  // '=='
  static final List<int> _strings12 = <int>[61, 61];
  
  // '!='
  static final List<int> _strings13 = <int>[33, 61];
  
  // '||'
  static final List<int> _strings14 = <int>[124, 124];
  
  // '%='
  static final List<int> _strings15 = <int>[37, 61];
  
  // '&='
  static final List<int> _strings16 = <int>[38, 61];
  
  // '*='
  static final List<int> _strings17 = <int>[42, 61];
  
  // '+='
  static final List<int> _strings18 = <int>[43, 61];
  
  // '-='
  static final List<int> _strings19 = <int>[45, 61];
  
  // '#ifndef'
  static final List<int> _strings2 = <int>[35, 105, 102, 110, 100, 101, 102];
  
  // '/='
  static final List<int> _strings20 = <int>[47, 61];
  
  // '<<='
  static final List<int> _strings21 = <int>[60, 60, 61];
  
  // '>>='
  static final List<int> _strings22 = <int>[62, 62, 61];
  
  // '^='
  static final List<int> _strings23 = <int>[94, 61];
  
  // '|='
  static final List<int> _strings24 = <int>[124, 61];
  
  // '#endif'
  static final List<int> _strings25 = <int>[35, 101, 110, 100, 105, 102];
  
  // '0x'
  static final List<int> _strings26 = <int>[48, 120];
  
  // '0X'
  static final List<int> _strings27 = <int>[48, 88];
  
  // '\r\n'
  static final List<int> _strings28 = <int>[13, 10];
  
  // '\u'
  static final List<int> _strings29 = <int>[92, 117];
  
  // 'L''
  static final List<int> _strings3 = <int>[76, 39];
  
  // '\U'
  static final List<int> _strings30 = <int>[92, 85];
  
  // '>='
  static final List<int> _strings31 = <int>[62, 61];
  
  // '<<'
  static final List<int> _strings32 = <int>[60, 60];
  
  // '<='
  static final List<int> _strings33 = <int>[60, 61];
  
  // 'LL'
  static final List<int> _strings34 = <int>[76, 76];
  
  // 'll'
  static final List<int> _strings35 = <int>[108, 108];
  
  // '\x'
  static final List<int> _strings4 = <int>[92, 120];
  
  // 'L"'
  static final List<int> _strings5 = <int>[76, 34];
  
  // '#elif'
  static final List<int> _strings6 = <int>[35, 101, 108, 105, 102];
  
  // '#else'
  static final List<int> _strings7 = <int>[35, 101, 108, 115, 101];
  
  // '#define'
  static final List<int> _strings8 = <int>[35, 100, 101, 102, 105, 110, 101];
  
  // '#undef'
  static final List<int> _strings9 = <int>[35, 117, 110, 100, 101, 102];
  
  final List<int> _tokenFlags = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0];
  
  final List<String> _tokenNames = ["identifier", "identifier1", "integer_constant", "decimal_constant", "decimal_constant1", "\'0\'", "octal_constant1", "hexadecimal_constant", "hexadecimal_constant1", "character_constant", "c_char_sequence", "c_char", "escape_sequence", "\'\\x\'", "hexadecimal_escape_sequence1", "string_literal", "s_char_sequence", "s_char", "replacement_list", "pp_tokens", "preprocessing_token", "pp_number", "pp_number1", "\'#undef\'", "\'#error\'", "digit", "floating_constant", "hexadecimal_digit", "hexadecimal_prefix", "identifier_nondigit", "integer_suffix", "new_line", "nonzero_digit", "octal_digit", "\'\\\'", "punctuator", "sign", "simple_escape_sequence", "universal_character_name", "\'&\'", "\'*\'", "\'!\'", "\'>\'", "\'>=\'", "\'<<\'", "\'<\'", "\'<=\'", "\'+\'", "\'%\'", "\'+\'", "\'<<\'", "\'/\'", "\'~\'", "binary_exponent_part", "decimal_floating_constant", "digit_sequence", "exponent_part", "floating_suffix", "fractional_constant", "hex_quad", "hexadecimal_digit_sequence", "hexadecimal_floating_constant", "hexadecimal_fractional_constant", "long_long_suffix", "long_suffix", "nondigit", "spaces", "unsigned_suffix"];
  
  static final List<List<int>> _transitions0 = [[33, 34, 38, 40, 42, 43, 45, 46, 48, 57, 65, 90, 92, 92, 97, 122, 126, 126]];
  
  static final List<List<int>> _transitions1 = [[33, 33, 38, 38, 42, 43, 126, 126], [34, 34, 39, 40, 45, 46, 48, 57, 65, 90, 92, 92, 97, 122]];
  
  static final List<List<int>> _transitions10 = [[39, 39], [76, 76]];
  
  static final List<List<int>> _transitions11 = [[34, 34, 39, 39, 63, 63, 97, 98, 102, 102, 110, 110, 114, 114, 116, 116, 118, 118], [92, 92]];
  
  static final List<List<int>> _transitions12 = [[34, 34], [76, 76]];
  
  static final List<List<int>> _transitions13 = [[0, 43, 45, 1114111], [44, 44]];
  
  static final List<List<int>> _transitions14 = [[0, 36, 38, 41, 43, 46, 48, 1114111], [37, 37, 42, 42, 47, 47]];
  
  static final List<List<int>> _transitions15 = [[0, 42, 44, 1114111], [43, 43]];
  
  static final List<List<int>> _transitions16 = [[0, 59, 61, 1114111], [60, 60]];
  
  static final List<List<int>> _transitions17 = [[0, 59, 61, 61, 63, 1114111], [60, 60, 62, 62]];
  
  static final List<List<int>> _transitions18 = [[0, 32, 34, 60, 62, 1114111], [33, 33], [61, 61]];
  
  static final List<List<int>> _transitions19 = [[0, 37, 39, 1114111], [38, 38]];
  
  static final List<List<int>> _transitions2 = [[34, 34], [39, 39, 46, 46, 48, 57], [40, 40], [45, 45, 92, 92], [65, 90], [97, 122]];
  
  static final List<List<int>> _transitions20 = [[0, 93, 95, 1114111], [94, 94]];
  
  static final List<List<int>> _transitions21 = [[0, 123, 125, 1114111], [124, 124]];
  
  static final List<List<int>> _transitions22 = [[33, 63, 65, 93, 97, 123, 125, 126]];
  
  static final List<List<int>> _transitions23 = [[33, 33, 35, 38, 40, 44, 47, 47, 58, 63, 91, 91, 93, 93, 123, 123, 125, 126], [34, 34], [39, 39], [45, 45], [46, 46], [48, 57], [65, 90], [92, 92, 97, 122]];
  
  static final List<List<int>> _transitions24 = [[46, 46], [48, 57]];
  
  static final List<List<int>> _transitions25 = [[0, 44, 47, 47, 58, 64, 91, 91, 93, 96, 123, 1114111], [45, 45, 92, 92], [46, 46], [48, 57], [65, 90], [97, 122]];
  
  static final List<List<int>> _transitions26 = [[10, 10, 13, 13, 33, 63, 65, 93, 97, 123, 125, 126]];
  
  static final List<List<int>> _transitions27 = [[37, 37], [38, 38], [42, 42], [43, 43], [45, 45], [47, 47], [60, 60], [61, 61], [62, 62], [94, 94], [124, 124]];
  
  static final List<List<int>> _transitions28 = [[46, 46], [48, 57], [80, 80, 112, 112]];
  
  static final List<List<int>> _transitions29 = [[48, 97, 102, 102]];
  
  static final List<List<int>> _transitions3 = [[45, 45, 65, 90, 92, 92, 97, 122]];
  
  static final List<List<int>> _transitions30 = [[45, 45, 65, 90, 97, 122], [92, 92]];
  
  static final List<List<int>> _transitions31 = [[76, 76, 108, 108], [85, 85, 117, 117]];
  
  static final List<List<int>> _transitions32 = [[37, 37], [42, 42], [47, 47]];
  
  static final List<List<int>> _transitions33 = [[10, 10], [13, 13]];
  
  static final List<List<int>> _transitions34 = [[33, 33, 35, 38, 40, 47, 58, 63, 91, 91, 93, 93, 123, 123, 125, 126]];
  
  static final List<List<int>> _transitions35 = [[60, 60], [62, 62]];
  
  static final List<List<int>> _transitions36 = [[43, 43, 45, 45]];
  
  static final List<List<int>> _transitions37 = [[34, 34, 39, 39, 63, 63, 92, 92, 97, 98, 102, 102, 110, 110, 114, 114, 116, 116, 118, 118]];
  
  static final List<List<int>> _transitions38 = [[33, 33], [38, 38], [42, 42], [43, 43], [126, 126]];
  
  static final List<List<int>> _transitions39 = [[80, 80], [112, 112]];
  
  static final List<List<int>> _transitions4 = [[0, 44, 46, 47, 58, 64, 91, 91, 93, 96, 123, 1114111], [45, 45, 65, 90, 92, 92, 97, 122], [48, 57]];
  
  static final List<List<int>> _transitions40 = [[69, 69], [101, 101]];
  
  static final List<List<int>> _transitions41 = [[70, 70, 76, 76, 102, 102, 108, 108]];
  
  static final List<List<int>> _transitions42 = [[48, 48], [80, 80, 112, 112]];
  
  static final List<List<int>> _transitions43 = [[46, 46], [48, 97, 102, 102]];
  
  static final List<List<int>> _transitions44 = [[76, 76], [108, 108]];
  
  static final List<List<int>> _transitions45 = [[76, 76, 108, 108]];
  
  static final List<List<int>> _transitions46 = [[45, 45, 65, 90, 97, 122]];
  
  static final List<List<int>> _transitions47 = [[9, 10, 13, 13, 32, 32]];
  
  static final List<List<int>> _transitions48 = [[85, 85, 117, 117]];
  
  static final List<List<int>> _transitions5 = [[39, 39, 76, 76], [46, 46, 80, 80, 112, 112], [48, 57]];
  
  static final List<List<int>> _transitions6 = [[48, 48], [49, 57]];
  
  static final List<List<int>> _transitions7 = [[0, 47, 58, 1114111], [48, 57]];
  
  static final List<List<int>> _transitions8 = [[0, 47, 56, 1114111], [48, 55]];
  
  static final List<List<int>> _transitions9 = [[0, 47, 98, 101, 103, 1114111], [48, 97, 102, 102]];
  
  List _cache;
  
  int _cachePos;
  
  List<int> _cacheRule;
  
  List<int> _cacheState;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<PParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenLevel;
  
  int _tokenStart;
  
  List<int> _trackPos;
  
  bool success;
  
  final String text;
  
  PParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;
    if (_inputLen >= 0x3fffffe8 / 32) {
      throw new StateError('File size to big: $_inputLen');
    }  
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {  
    var cached = _cache[start];
    if (cached == null) {
      _cacheRule[start] = id;
      _cache[start] = [result, _cursor, success];
    } else {    
      var slot = start >> 5;
      var r1 = (slot << 5) & 0x3fffffff;    
      var mask = 1 << (start - r1);    
      if ((_cacheState[slot] & mask) == 0) {
        _cacheState[slot] |= mask;   
        cached = [new List.filled(5, 0), new Map<int, List>()];
        _cache[start] = cached;                                      
      }
      slot = id >> 5;
      r1 = (slot << 5) & 0x3fffffff;    
      mask = 1 << (id - r1);    
      cached[0][slot] |= mask;
      cached[1][id] = [result, _cursor, success];      
    }
    if (_cachePos < start) {
      _cachePos = start;
    }    
  }
  
  void _beginToken(int tokenId) {
    if (_tokenLevel++ == 0) {
      _token = tokenId;
      _tokenStart = _cursor;
    }  
  }
  
  void _endToken() {
    if (--_tokenLevel == 0) {
      _token = null;
      _tokenStart = null;
    }    
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated $name";
        _errors.add(new PParserError(PParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed $name";
        _errors.add(new PParserError(PParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(name);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {
      if (_trackPos[id] < _cursor) {
        _trackPos[id] = _cursor;
        return null;
      } else {
        _cacheable[id] = true;            
      }
    }  
    var result = _cache[_cursor];
    if (result == null) {
      return null;
    }    
    var slot = _cursor >> 5;
    var r1 = (slot << 5) & 0x3fffffff;  
    var mask = 1 << (_cursor - r1);
    if ((_cacheState[slot] & mask) == 0) {
      if (_cacheRule[_cursor] == id) {      
        _cursor = result[1];
        success = result[2];      
        if (_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      } else {
        return null;
      }    
    }
    slot = id >> 5;
    r1 = (slot << 5) & 0x3fffffff;  
    mask = 1 << (id - r1);
    if ((result[0][slot] & mask) == 0) {
      return null;
    }
    var data = result[1][id];  
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }   
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_AMPERSAND() {
    // MORPHEME
    // AMPERSAND <- '&' spaces
    var $$;
    _beginToken(39);  
    // => '&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&'
          $$ = '&';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&'
      _failure(_expect47);
    }
    // <= '&' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_AND1() {
    // LEXEME
    // AND1 <- '&' spaces
    var $$;
    // => '&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&'
          $$ = '&';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&'
      _failure(_expect47);
    }
    // <= '&' spaces # Choice
    return $$;
  }
  
  dynamic _parse_AND2() {
    // LEXEME
    // AND2 <- '&&' spaces
    var $$;
    // => '&&' spaces # Choice
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      // [&]
      case 0:
        // => '&&' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '&&'
          $$ = _matchString(_strings11, '&&');
          // <= '&&'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '&&' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&&'
      _failure(_expect48);
    }
    // <= '&&' spaces # Choice
    return $$;
  }
  
  dynamic _parse_AND_expression() {
    // NONTERMINAL
    // AND_expression <- equality_expression AND_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(11);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => equality_expression AND_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => equality_expression AND_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => equality_expression
          $$ = _parse_equality_expression();
          // <= equality_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => AND_expression1
          $$ = _parse_AND_expression1();
          // <= AND_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= equality_expression AND_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= equality_expression AND_expression1 # Choice
    if (_cacheable[11]) {
      _addToCache($$, pos, 11);
    }  
    return $$;
  }
  
  dynamic _parse_AND_expression1() {
    // NONTERMINAL
    // AND_expression1 <- AND1 equality_expression AND_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(46);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => AND1 equality_expression AND_expression1 / '' # Choice
    switch (_getState(_transitions19)) {
      // [\u0000-%] [\'-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [&]
      case 1:
        while (true) {
          // => AND1 equality_expression AND_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => AND1
            $$ = _parse_AND1();
            // <= AND1
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => equality_expression
            $$ = _parse_equality_expression();
            // <= equality_expression
            if (!success) break;
            seq[1] = $$;
            // => AND_expression1
            $$ = _parse_AND_expression1();
            // <= AND_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= AND1 equality_expression AND_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&', null
      _failure(_expect30);
    }
    // <= AND1 equality_expression AND_expression1 / '' # Choice
    if (_cacheable[46]) {
      _addToCache($$, pos, 46);
    }  
    return $$;
  }
  
  dynamic _parse_ASTERISK() {
    // MORPHEME
    // ASTERISK <- '*' spaces
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(98);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(40);    
    // => '*' spaces # Choice
    switch (_ch == 42 ? 0 : _ch == -1 ? 2 : 1) {
      // [*]
      case 0:
        // => '*' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '*'
          $$ = '*';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '*'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '*' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '*'
      _failure(_expect80);
    }
    // <= '*' spaces # Choice
    if (_cacheable[98]) {
      _addToCache($$, pos, 98);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_COMMA() {
    // LEXEME
    // COMMA <- ',' spaces
    var $$;
    // => ',' spaces # Choice
    switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
      // [,]
      case 0:
        // => ',' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ','
          $$ = ',';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ','
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ',' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ','
      _failure(_expect49);
    }
    // <= ',' spaces # Choice
    return $$;
  }
  
  dynamic _parse_EOF() {
    // LEXEME
    // EOF <- !.
    var $$;
    // => !. # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => !.
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        // => .
        $$ = _matchAny();
        // <= .
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        // <= !.
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= !. # Choice
    return $$;
  }
  
  dynamic _parse_EQ() {
    // LEXEME
    // EQ <- '==' spaces
    var $$;
    // => '==' spaces # Choice
    switch (_ch == 61 ? 0 : _ch == -1 ? 2 : 1) {
      // [=]
      case 0:
        // => '==' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '=='
          $$ = _matchString(_strings12, '==');
          // <= '=='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '==' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '=='
      _failure(_expect50);
    }
    // <= '==' spaces # Choice
    return $$;
  }
  
  dynamic _parse_EXCLAMATION() {
    // MORPHEME
    // EXCLAMATION <- '!' spaces
    var $$;
    _beginToken(41);  
    // => '!' spaces # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!'
          $$ = '!';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '!'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '!'
      _failure(_expect81);
    }
    // <= '!' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_GT() {
    // MORPHEME
    // GT <- '>' spaces
    var $$;
    _beginToken(42);  
    // => '>' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>'
          $$ = '>';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '>'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '>'
      _failure(_expect82);
    }
    // <= '>' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_GTE() {
    // MORPHEME
    // GTE <- '>=' spaces
    var $$;
    _beginToken(43);  
    // => '>=' spaces # Choice
    switch (_ch == 62 ? 0 : _ch == -1 ? 2 : 1) {
      // [>]
      case 0:
        // => '>=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '>='
          $$ = _matchString(_strings31, '>=');
          // <= '>='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '>=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '>='
      _failure(_expect83);
    }
    // <= '>=' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_LSH() {
    // MORPHEME
    // LSH <- '<<' spaces
    var $$;
    _beginToken(44);  
    // => '<<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<<'
          $$ = _matchString(_strings32, '<<');
          // <= '<<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<<'
      _failure(_expect75);
    }
    // <= '<<' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_LT() {
    // MORPHEME
    // LT <- '<' spaces
    var $$;
    _beginToken(45);  
    // => '<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<'
          $$ = '<';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<'
      _failure(_expect84);
    }
    // <= '<' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_LTE() {
    // MORPHEME
    // LTE <- '<=' spaces
    var $$;
    _beginToken(46);  
    // => '<=' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<='
          $$ = _matchString(_strings33, '<=');
          // <= '<='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<='
      _failure(_expect85);
    }
    // <= '<=' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_MINUS() {
    // MORPHEME
    // MINUS <- '+' spaces
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(106);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(47);    
    // => '+' spaces # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '+'
      _failure(_expect57);
    }
    // <= '+' spaces # Choice
    if (_cacheable[106]) {
      _addToCache($$, pos, 106);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_NEQ() {
    // LEXEME
    // NEQ <- '!=' spaces
    var $$;
    // => '!=' spaces # Choice
    switch (_ch == 33 ? 0 : _ch == -1 ? 2 : 1) {
      // [!]
      case 0:
        // => '!=' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '!='
          $$ = _matchString(_strings13, '!=');
          // <= '!='
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '!=' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '!='
      _failure(_expect51);
    }
    // <= '!=' spaces # Choice
    return $$;
  }
  
  dynamic _parse_OR1() {
    // LEXEME
    // OR1 <- '|' spaces
    var $$;
    // => '|' spaces # Choice
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      // [|]
      case 0:
        // => '|' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '|'
          $$ = '|';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '|'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '|' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '|'
      _failure(_expect52);
    }
    // <= '|' spaces # Choice
    return $$;
  }
  
  dynamic _parse_OR2() {
    // LEXEME
    // OR2 <- '||' spaces
    var $$;
    // => '||' spaces # Choice
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      // [|]
      case 0:
        // => '||' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '||'
          $$ = _matchString(_strings14, '||');
          // <= '||'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '||' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '||'
      _failure(_expect53);
    }
    // <= '||' spaces # Choice
    return $$;
  }
  
  dynamic _parse_PERCENT() {
    // MORPHEME
    // PERCENT <- '%' spaces
    var $$;
    _beginToken(48);  
    // => '%' spaces # Choice
    switch (_ch == 37 ? 0 : _ch == -1 ? 2 : 1) {
      // [%]
      case 0:
        // => '%' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '%'
          $$ = '%';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '%'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '%' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '%'
      _failure(_expect86);
    }
    // <= '%' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_PLUS() {
    // MORPHEME
    // PLUS <- '+' spaces
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(108);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(49);    
    // => '+' spaces # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        // => '+' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '+'
          $$ = '+';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '+'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '+' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '+'
      _failure(_expect57);
    }
    // <= '+' spaces # Choice
    if (_cacheable[108]) {
      _addToCache($$, pos, 108);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_QUESTION() {
    // LEXEME
    // QUESTION <- '?' spaces
    var $$;
    // => '?' spaces # Choice
    switch (_ch == 63 ? 0 : _ch == -1 ? 2 : 1) {
      // [?]
      case 0:
        // => '?' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '?'
          $$ = '?';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '?'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '?' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '?'
      _failure(_expect54);
    }
    // <= '?' spaces # Choice
    return $$;
  }
  
  dynamic _parse_RSH() {
    // MORPHEME
    // RSH <- '<<' spaces
    var $$;
    _beginToken(50);  
    // => '<<' spaces # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        // => '<<' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '<<'
          $$ = _matchString(_strings32, '<<');
          // <= '<<'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '<<' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<<'
      _failure(_expect75);
    }
    // <= '<<' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_SEMICOLON() {
    // LEXEME
    // SEMICOLON <- ':' spaces
    var $$;
    // => ':' spaces # Choice
    switch (_ch == 58 ? 0 : _ch == -1 ? 2 : 1) {
      // [:]
      case 0:
        // => ':' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ':'
          $$ = ':';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ':'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ':' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ':'
      _failure(_expect55);
    }
    // <= ':' spaces # Choice
    return $$;
  }
  
  dynamic _parse_SLASH() {
    // MORPHEME
    // SLASH <- '/' spaces
    var $$;
    _beginToken(51);  
    // => '/' spaces # Choice
    switch (_ch == 47 ? 0 : _ch == -1 ? 2 : 1) {
      // [/]
      case 0:
        // => '/' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '/'
          $$ = '/';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '/'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '/' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '/'
      _failure(_expect87);
    }
    // <= '/' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_TILDE() {
    // MORPHEME
    // TILDE <- '~' spaces
    var $$;
    _beginToken(52);  
    // => '~' spaces # Choice
    switch (_ch == 126 ? 0 : _ch == -1 ? 2 : 1) {
      // [~]
      case 0:
        // => '~' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '~'
          $$ = '~';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '~'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '~' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '~'
      _failure(_expect88);
    }
    // <= '~' spaces # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_XOR() {
    // LEXEME
    // XOR <- '^' spaces
    var $$;
    // => '^' spaces # Choice
    switch (_ch == 94 ? 0 : _ch == -1 ? 2 : 1) {
      // [^]
      case 0:
        // => '^' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '^'
          $$ = '^';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '^'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '^' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '^'
      _failure(_expect56);
    }
    // <= '^' spaces # Choice
    return $$;
  }
  
  dynamic _parse_additive_expression() {
    // NONTERMINAL
    // additive_expression <- multiplicative_expression additive_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(15);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => multiplicative_expression additive_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => multiplicative_expression additive_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => multiplicative_expression
          $$ = _parse_multiplicative_expression();
          // <= multiplicative_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => additive_expression1
          $$ = _parse_additive_expression1();
          // <= additive_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= multiplicative_expression additive_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= multiplicative_expression additive_expression1 # Choice
    if (_cacheable[15]) {
      _addToCache($$, pos, 15);
    }  
    return $$;
  }
  
  dynamic _parse_additive_expression1() {
    // NONTERMINAL
    // additive_expression1 <- additive_operator multiplicative_expression additive_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(42);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => additive_operator multiplicative_expression additive_expression1 / '' # Choice
    switch (_getState(_transitions15)) {
      // [\u0000-*] [,-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [+]
      case 1:
        while (true) {
          // => additive_operator multiplicative_expression additive_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => additive_operator
            $$ = _parse_additive_operator();
            // <= additive_operator
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => multiplicative_expression
            $$ = _parse_multiplicative_expression();
            // <= multiplicative_expression
            if (!success) break;
            seq[1] = $$;
            // => additive_expression1
            $$ = _parse_additive_expression1();
            // <= additive_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= additive_operator multiplicative_expression additive_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '+', null
      _failure(_expect26);
    }
    // <= additive_operator multiplicative_expression additive_expression1 / '' # Choice
    if (_cacheable[42]) {
      _addToCache($$, pos, 42);
    }  
    return $$;
  }
  
  dynamic _parse_additive_operator() {
    // LEXEME
    // additive_operator <- PLUS / MINUS
    var $$;
    // => PLUS / MINUS # Choice
    switch (_ch == 43 ? 0 : _ch == -1 ? 2 : 1) {
      // [+]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => PLUS
          $$ = _parse_PLUS();
          // <= PLUS
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => MINUS
          $$ = _parse_MINUS();
          // <= MINUS
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '+'
      _failure(_expect57);
    }
    // <= PLUS / MINUS # Choice
    return $$;
  }
  
  dynamic _parse_assignment_expression() {
    // NONTERMINAL
    // assignment_expression <- conditional_expression / unary_expression assignment_operator assignment_expression
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(39);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => conditional_expression / unary_expression assignment_operator assignment_expression # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => conditional_expression
          $$ = _parse_conditional_expression();
          // <= conditional_expression
          _startPos = startPos0;
          if (success) break;
          // => unary_expression assignment_operator assignment_expression # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => unary_expression
            $$ = _parse_unary_expression();
            // <= unary_expression
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => assignment_operator
            $$ = _parse_assignment_operator();
            // <= assignment_operator
            if (!success) break;
            seq[1] = $$;
            // => assignment_expression
            $$ = _parse_assignment_expression();
            // <= assignment_expression
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= unary_expression assignment_operator assignment_expression # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= conditional_expression / unary_expression assignment_operator assignment_expression # Choice
    if (_cacheable[39]) {
      _addToCache($$, pos, 39);
    }  
    return $$;
  }
  
  dynamic _parse_assignment_operator() {
    // LEXEME
    // assignment_operator <- '=' / '*=' / '/=' / '%=' / '+=' / '-=' / '<<=' / '>>=' / '&=' / '^=' / '|='
    var $$;
    // => '=' / '*=' / '/=' / '%=' / '+=' / '-=' / '<<=' / '>>=' / '&=' / '^=' / '|=' # Choice
    switch (_getState(_transitions27)) {
      // [%]
      case 0:
        var startPos0 = _startPos;
        // => '%='
        $$ = _matchString(_strings15, '%=');
        // <= '%='
        _startPos = startPos0;
        break;
      // [&]
      case 1:
        var startPos1 = _startPos;
        // => '&='
        $$ = _matchString(_strings16, '&=');
        // <= '&='
        _startPos = startPos1;
        break;
      // [*]
      case 2:
        var startPos2 = _startPos;
        // => '*='
        $$ = _matchString(_strings17, '*=');
        // <= '*='
        _startPos = startPos2;
        break;
      // [+]
      case 3:
        var startPos3 = _startPos;
        // => '+='
        $$ = _matchString(_strings18, '+=');
        // <= '+='
        _startPos = startPos3;
        break;
      // [-]
      case 4:
        var startPos4 = _startPos;
        // => '-='
        $$ = _matchString(_strings19, '-=');
        // <= '-='
        _startPos = startPos4;
        break;
      // [/]
      case 5:
        var startPos5 = _startPos;
        // => '/='
        $$ = _matchString(_strings20, '/=');
        // <= '/='
        _startPos = startPos5;
        break;
      // [<]
      case 6:
        var startPos6 = _startPos;
        // => '<<='
        $$ = _matchString(_strings21, '<<=');
        // <= '<<='
        _startPos = startPos6;
        break;
      // [=]
      case 7:
        var startPos7 = _startPos;
        // => '='
        $$ = '=';
        success = true;
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }
        // <= '='
        _startPos = startPos7;
        break;
      // [>]
      case 8:
        var startPos8 = _startPos;
        // => '>>='
        $$ = _matchString(_strings22, '>>=');
        // <= '>>='
        _startPos = startPos8;
        break;
      // [^]
      case 9:
        var startPos9 = _startPos;
        // => '^='
        $$ = _matchString(_strings23, '^=');
        // <= '^='
        _startPos = startPos9;
        break;
      // [|]
      case 10:
        var startPos10 = _startPos;
        // => '|='
        $$ = _matchString(_strings24, '|=');
        // <= '|='
        _startPos = startPos10;
        break;
      // No matches
      // EOF
      case 11:
      case 12:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: assignment_operator
      _failure(_expect58);
    }
    // <= '=' / '*=' / '/=' / '%=' / '+=' / '-=' / '<<=' / '>>=' / '&=' / '^=' / '|=' # Choice
    return $$;
  }
  
  dynamic _parse_binary_exponent_part() {
    // MORPHEME
    // binary_exponent_part <- 'p' sign? digit_sequence / 'P' sign? digit_sequence
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(112);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(53);    
    // => 'p' sign? digit_sequence / 'P' sign? digit_sequence # Choice
    switch (_getState(_transitions39)) {
      // [P]
      case 0:
        // => 'P' sign? digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'P'
          $$ = 'P';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= 'P'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => sign?
          var testing0 = _testing;
          _testing = _cursor;
          // => sign
          $$ = _parse_sign();
          // <= sign
          success = true; 
          _testing = testing0;
          // <= sign?
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'P' sign? digit_sequence # Sequence
        break;
      // [p]
      case 1:
        // => 'p' sign? digit_sequence # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'p'
          $$ = 'p';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= 'p'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => sign?
          var testing1 = _testing;
          _testing = _cursor;
          // => sign
          $$ = _parse_sign();
          // <= sign
          success = true; 
          _testing = testing1;
          // <= sign?
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'p' sign? digit_sequence # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: binary_exponent_part
      _failure(_expect89);
    }
    // <= 'p' sign? digit_sequence / 'P' sign? digit_sequence # Choice
    if (_cacheable[112]) {
      _addToCache($$, pos, 112);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_c_char() {
    // MORPHEME
    // c_char <- (![\n\r'\\]) / escape_sequence
    var $$;
    _beginToken(11);  
    // => (![\n\r'\\]) / escape_sequence # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => (![\n\r'\\]) # Choice
          switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
            // [\u0000-\u0010ffff]
            // EOF
            case 0:
            case 2:
              var startPos1 = _startPos;
              // => ![\n\r'\\]
              var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
              _testing = _inputLen + 1;
              // => [\n\r'\\]
              $$ = _matchMapping(10, 92, _mapping0);
              // <= [\n\r'\\]
              _ch = ch0;
              _cursor = pos0; 
              _testing = testing0;
              $$ = null;
              success = !success;
              // <= ![\n\r'\\]
              _startPos = startPos1;
              break;
            // No matches
            case 1:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: null
            _failure(_expect17);
          }
          // <= (![\n\r'\\]) # Choice
          _startPos = startPos0;
          if (success) break;
          var startPos2 = _startPos;
          // => escape_sequence
          $$ = _parse_escape_sequence();
          // <= escape_sequence
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
      // EOF
      case 2:
        var startPos3 = _startPos;
        // => (![\n\r'\\]) # Choice
        switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
          // [\u0000-\u0010ffff]
          // EOF
          case 0:
          case 2:
            var startPos4 = _startPos;
            // => ![\n\r'\\]
            var ch1 = _ch, pos1 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            // => [\n\r'\\]
            $$ = _matchMapping(10, 92, _mapping0);
            // <= [\n\r'\\]
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing1;
            $$ = null;
            success = !success;
            // <= ![\n\r'\\]
            _startPos = startPos4;
            break;
          // No matches
          case 1:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: null
          _failure(_expect17);
        }
        // <= (![\n\r'\\]) # Choice
        _startPos = startPos3;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: c_char
      _failure(_expect16);
    }
    // <= (![\n\r'\\]) / escape_sequence # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_c_char_sequence() {
    // MORPHEME
    // c_char_sequence <- c_char+
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(30);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(10);    
    // => c_char+ # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => c_char+
        var testing0;
        for (var first = true, reps; ;) {  
          // => c_char  
          $$ = _parse_c_char();  
          // <= c_char  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= c_char+
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: c_char_sequence
      _failure(_expect15);
    }
    // <= c_char+ # Choice
    if (_cacheable[30]) {
      _addToCache($$, pos, 30);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_character_constant() {
    // MORPHEME
    // character_constant <- '\'' c_char_sequence '\'' / 'L\'' c_char_sequence '\''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(29);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(9);    
    // => '\'' c_char_sequence '\'' / 'L\'' c_char_sequence '\'' # Choice
    switch (_getState(_transitions10)) {
      // [\']
      case 0:
        // => '\'' c_char_sequence '\'' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\''
          $$ = '\'';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '\''
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => c_char_sequence
          $$ = _parse_c_char_sequence();
          // <= c_char_sequence
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\'' c_char_sequence '\'' # Sequence
        break;
      // [L]
      case 1:
        // => 'L\'' c_char_sequence '\'' # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'L\''
          $$ = _matchString(_strings3, 'L\'');
          // <= 'L\''
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => c_char_sequence
          $$ = _parse_c_char_sequence();
          // <= c_char_sequence
          if (!success) break;
          seq[1] = $$;
          // => '\''
          $$ = _matchChar(39, '\'');
          // <= '\''
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'L\'' c_char_sequence '\'' # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: character_constant
      _failure(_expect14);
    }
    // <= '\'' c_char_sequence '\'' / 'L\'' c_char_sequence '\'' # Choice
    if (_cacheable[29]) {
      _addToCache($$, pos, 29);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_conditional_expression() {
    // NONTERMINAL
    // conditional_expression <- logical_OR_expression / logical_OR_expression QUESTION expression SEMICOLON conditional_expression
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(6);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => logical_OR_expression / logical_OR_expression QUESTION expression SEMICOLON conditional_expression # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => logical_OR_expression
          $$ = _parse_logical_OR_expression();
          // <= logical_OR_expression
          _startPos = startPos0;
          if (success) break;
          // => logical_OR_expression QUESTION expression SEMICOLON conditional_expression # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => logical_OR_expression
            $$ = _parse_logical_OR_expression();
            // <= logical_OR_expression
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => QUESTION
            $$ = _parse_QUESTION();
            // <= QUESTION
            if (!success) break;
            seq[1] = $$;
            // => expression
            $$ = _parse_expression();
            // <= expression
            if (!success) break;
            seq[2] = $$;
            // => SEMICOLON
            $$ = _parse_SEMICOLON();
            // <= SEMICOLON
            if (!success) break;
            seq[3] = $$;
            // => conditional_expression
            $$ = _parse_conditional_expression();
            // <= conditional_expression
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= logical_OR_expression QUESTION expression SEMICOLON conditional_expression # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= logical_OR_expression / logical_OR_expression QUESTION expression SEMICOLON conditional_expression # Choice
    if (_cacheable[6]) {
      _addToCache($$, pos, 6);
    }  
    return $$;
  }
  
  dynamic _parse_constant() {
    // LEXEME
    // constant <- integer_constant / floating_constant / character_constant
    var $$;
    // => integer_constant / floating_constant / character_constant # Choice
    switch (_getState(_transitions5)) {
      // [\'] [L]
      case 0:
        var startPos0 = _startPos;
        // => character_constant
        $$ = _parse_character_constant();
        // <= character_constant
        _startPos = startPos0;
        break;
      // [.] [P] [p]
      case 1:
        var startPos1 = _startPos;
        // => floating_constant
        $$ = _parse_floating_constant();
        // <= floating_constant
        _startPos = startPos1;
        break;
      // [0-9]
      case 2:
        while (true) {
          var startPos2 = _startPos;
          // => integer_constant
          $$ = _parse_integer_constant();
          // <= integer_constant
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          // => floating_constant
          $$ = _parse_floating_constant();
          // <= floating_constant
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: constant
      _failure(_expect6);
    }
    // <= integer_constant / floating_constant / character_constant # Choice
    return $$;
  }
  
  dynamic _parse_constant_expression() {
    // NONTERMINAL
    // constant_expression <- conditional_expression
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(5);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => conditional_expression # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        var startPos0 = _startPos;
        // => conditional_expression
        $$ = _parse_conditional_expression();
        // <= conditional_expression
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= conditional_expression # Choice
    if (_cacheable[5]) {
      _addToCache($$, pos, 5);
    }  
    return $$;
  }
  
  dynamic _parse_control_line() {
    // LEXEME
    // control_line <- '#define' identifier replacement_list new_line / undef / error
    var $$;
    // => '#define' identifier replacement_list new_line / undef / error # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        while (true) {
          // => '#define' identifier replacement_list new_line # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '#define'
            $$ = _matchString(_strings8, '#define');
            // <= '#define'
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => identifier
            $$ = _parse_identifier();
            // <= identifier
            if (!success) break;
            seq[1] = $$;
            // => replacement_list
            $$ = _parse_replacement_list();
            // <= replacement_list
            if (!success) break;
            seq[2] = $$;
            // => new_line
            $$ = _parse_new_line();
            // <= new_line
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '#define' identifier replacement_list new_line # Sequence
          if (success) break;
          var startPos1 = _startPos;
          // => undef
          $$ = _parse_undef();
          // <= undef
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => error
          $$ = _parse_error();
          // <= error
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: control_line
      _failure(_expect37);
    }
    // <= '#define' identifier replacement_list new_line / undef / error # Choice
    return $$;
  }
  
  dynamic _parse_decimal_constant() {
    // MORPHEME
    // decimal_constant <- nonzero_digit decimal_constant1
    var $$;
    _beginToken(3);  
    // => nonzero_digit decimal_constant1 # Choice
    switch (_ch >= 49 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [1-9]
      case 0:
        // => nonzero_digit decimal_constant1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => nonzero_digit
          $$ = _parse_nonzero_digit();
          // <= nonzero_digit
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => decimal_constant1
          $$ = _parse_decimal_constant1();
          // <= decimal_constant1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= nonzero_digit decimal_constant1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: decimal_constant
      _failure(_expect8);
    }
    // <= nonzero_digit decimal_constant1 # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_decimal_constant1() {
    // MORPHEME
    // decimal_constant1 <- digit decimal_constant1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(24);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(4);    
    // => digit decimal_constant1 / '' # Choice
    switch (_getState(_transitions7)) {
      // [\u0000-/] [:-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-9]
      case 1:
        while (true) {
          // => digit decimal_constant1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit
            $$ = _parse_digit();
            // <= digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => decimal_constant1
            $$ = _parse_decimal_constant1();
            // <= decimal_constant1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= digit decimal_constant1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: decimal_constant1
      _failure(_expect9);
    }
    // <= digit decimal_constant1 / '' # Choice
    if (_cacheable[24]) {
      _addToCache($$, pos, 24);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_decimal_floating_constant() {
    // MORPHEME
    // decimal_floating_constant <- fractional_constant exponent_part? floating_suffix? / digit_sequence exponent_part floating_suffix?
    var $$;
    _beginToken(54);  
    // => fractional_constant exponent_part? floating_suffix? / digit_sequence exponent_part floating_suffix? # Choice
    switch (_getState(_transitions24)) {
      // [.]
      case 0:
        // => fractional_constant exponent_part? floating_suffix? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => fractional_constant
          $$ = _parse_fractional_constant();
          // <= fractional_constant
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => exponent_part?
          var testing0 = _testing;
          _testing = _cursor;
          // => exponent_part
          $$ = _parse_exponent_part();
          // <= exponent_part
          success = true; 
          _testing = testing0;
          // <= exponent_part?
          if (!success) break;
          seq[1] = $$;
          // => floating_suffix?
          var testing1 = _testing;
          _testing = _cursor;
          // => floating_suffix
          $$ = _parse_floating_suffix();
          // <= floating_suffix
          success = true; 
          _testing = testing1;
          // <= floating_suffix?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= fractional_constant exponent_part? floating_suffix? # Sequence
        break;
      // [0-9]
      case 1:
        while (true) {
          // => fractional_constant exponent_part? floating_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => fractional_constant
            $$ = _parse_fractional_constant();
            // <= fractional_constant
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => exponent_part?
            var testing2 = _testing;
            _testing = _cursor;
            // => exponent_part
            $$ = _parse_exponent_part();
            // <= exponent_part
            success = true; 
            _testing = testing2;
            // <= exponent_part?
            if (!success) break;
            seq[1] = $$;
            // => floating_suffix?
            var testing3 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing3;
            // <= floating_suffix?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= fractional_constant exponent_part? floating_suffix? # Sequence
          if (success) break;
          // => digit_sequence exponent_part floating_suffix? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => exponent_part
            $$ = _parse_exponent_part();
            // <= exponent_part
            if (!success) break;
            seq[1] = $$;
            // => floating_suffix?
            var testing4 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing4;
            // <= floating_suffix?
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= digit_sequence exponent_part floating_suffix? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: decimal_floating_constant
      _failure(_expect90);
    }
    // <= fractional_constant exponent_part? floating_suffix? / digit_sequence exponent_part floating_suffix? # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_digit() {
    // MORPHEME
    // digit <- [0-9]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(76);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(25);    
    // => [0-9] # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => [0-9]
        $$ = _matchRange(48, 57);
        // <= [0-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: digit
      _failure(_expect59);
    }
    // <= [0-9] # Choice
    if (_cacheable[76]) {
      _addToCache($$, pos, 76);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_digit_sequence() {
    // MORPHEME
    // digit_sequence <- digit+
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(114);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(55);    
    // => digit+ # Choice
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-9]
      case 0:
        var startPos0 = _startPos;
        // => digit+
        var testing0;
        for (var first = true, reps; ;) {  
          // => digit  
          $$ = _parse_digit();  
          // <= digit  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= digit+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: digit_sequence
      _failure(_expect91);
    }
    // <= digit+ # Choice
    if (_cacheable[114]) {
      _addToCache($$, pos, 114);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_elif_group() {
    // NONTERMINAL
    // elif_group <- '#elif' constant_expression new_line group?
    var $$;
    // => '#elif' constant_expression new_line group? # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => '#elif' constant_expression new_line group? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '#elif'
          $$ = _matchString(_strings6, '#elif');
          // <= '#elif'
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => constant_expression
          $$ = _parse_constant_expression();
          // <= constant_expression
          if (!success) break;
          seq[1] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[2] = $$;
          // => group?
          var testing0 = _testing;
          _testing = _cursor;
          // => group
          $$ = _parse_group();
          // <= group
          success = true; 
          _testing = testing0;
          // <= group?
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '#elif' constant_expression new_line group? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #elif
      _failure(_expect35);
    }
    // <= '#elif' constant_expression new_line group? # Choice
    return $$;
  }
  
  dynamic _parse_elif_groups() {
    // NONTERMINAL
    // elif_groups <- elif_group+
    var $$;
    // => elif_group+ # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        var startPos0 = _startPos;
        // => elif_group+
        var testing0;
        for (var first = true, reps; ;) {  
          // => elif_group  
          $$ = _parse_elif_group();  
          // <= elif_group  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= elif_group+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #elif
      _failure(_expect35);
    }
    // <= elif_group+ # Choice
    return $$;
  }
  
  dynamic _parse_else_group() {
    // NONTERMINAL
    // else_group <- '#else' new_line group?
    var $$;
    // => '#else' new_line group? # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => '#else' new_line group? # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '#else'
          $$ = _matchString(_strings7, '#else');
          // <= '#else'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[1] = $$;
          // => group?
          var testing0 = _testing;
          _testing = _cursor;
          // => group
          $$ = _parse_group();
          // <= group
          success = true; 
          _testing = testing0;
          // <= group?
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '#else' new_line group? # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #else
      _failure(_expect36);
    }
    // <= '#else' new_line group? # Choice
    return $$;
  }
  
  dynamic _parse_endif_line() {
    // LEXEME
    // endif_line <- '#endif' new_line
    var $$;
    // => '#endif' new_line # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => '#endif' new_line # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '#endif'
          $$ = _matchString(_strings25, '#endif');
          // <= '#endif'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '#endif' new_line # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '#endif'
      _failure(_expect60);
    }
    // <= '#endif' new_line # Choice
    return $$;
  }
  
  dynamic _parse_equality_expression() {
    // NONTERMINAL
    // equality_expression <- relational_expression equality_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(12);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => relational_expression equality_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => relational_expression equality_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => relational_expression
          $$ = _parse_relational_expression();
          // <= relational_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => equality_expression1
          $$ = _parse_equality_expression1();
          // <= equality_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= relational_expression equality_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= relational_expression equality_expression1 # Choice
    if (_cacheable[12]) {
      _addToCache($$, pos, 12);
    }  
    return $$;
  }
  
  dynamic _parse_equality_expression1() {
    // NONTERMINAL
    // equality_expression1 <- EQ relational_expression equality_expression1 / NEQ relational_expression equality_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(45);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => EQ relational_expression equality_expression1 / NEQ relational_expression equality_expression1 / '' # Choice
    switch (_getState(_transitions18)) {
      // [\u0000- ] [\"-<] [>-\u0010ffff]
      // EOF
      case 0:
      case 4:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [!]
      case 1:
        while (true) {
          // => NEQ relational_expression equality_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => NEQ
            $$ = _parse_NEQ();
            // <= NEQ
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => relational_expression
            $$ = _parse_relational_expression();
            // <= relational_expression
            if (!success) break;
            seq[1] = $$;
            // => equality_expression1
            $$ = _parse_equality_expression1();
            // <= equality_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= NEQ relational_expression equality_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // [=]
      case 2:
        while (true) {
          // => EQ relational_expression equality_expression1 # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => EQ
            $$ = _parse_EQ();
            // <= EQ
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => relational_expression
            $$ = _parse_relational_expression();
            // <= relational_expression
            if (!success) break;
            seq[1] = $$;
            // => equality_expression1
            $$ = _parse_equality_expression1();
            // <= equality_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos3;
          // <= EQ relational_expression equality_expression1 # Sequence
          if (success) break;
          var startPos4 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos4;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '==', '!=', null
      _failure(_expect29);
    }
    // <= EQ relational_expression equality_expression1 / NEQ relational_expression equality_expression1 / '' # Choice
    if (_cacheable[45]) {
      _addToCache($$, pos, 45);
    }  
    return $$;
  }
  
  dynamic _parse_error() {
    // MORPHEME
    // error <- '#error' pp_tokens? new_line
    var $$;
    _beginToken(24);  
    // => '#error' pp_tokens? new_line # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => '#error' pp_tokens? new_line # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '#error'
          $$ = _matchString(_strings10, '#error');
          // <= '#error'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => pp_tokens?
          var testing0 = _testing;
          _testing = _cursor;
          // => pp_tokens
          $$ = _parse_pp_tokens();
          // <= pp_tokens
          success = true; 
          _testing = testing0;
          // <= pp_tokens?
          if (!success) break;
          seq[1] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '#error' pp_tokens? new_line # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '#error'
      _failure(_expect44);
    }
    // <= '#error' pp_tokens? new_line # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_escape_sequence() {
    // MORPHEME
    // escape_sequence <- simple_escape_sequence / octal_escape_sequence / hexadecimal_escape_sequence / universal_character_name
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(32);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(12);    
    // => simple_escape_sequence / octal_escape_sequence / hexadecimal_escape_sequence / universal_character_name # Choice
    switch (_getState(_transitions11)) {
      // [\"] [\'] [?] [a-b] [f] [n] [r] [t] [v]
      case 0:
        var startPos0 = _startPos;
        // => simple_escape_sequence
        $$ = _parse_simple_escape_sequence();
        // <= simple_escape_sequence
        _startPos = startPos0;
        break;
      // [\\]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => simple_escape_sequence
          $$ = _parse_simple_escape_sequence();
          // <= simple_escape_sequence
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => octal_escape_sequence
          $$ = _parse_octal_escape_sequence();
          // <= octal_escape_sequence
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          // => hexadecimal_escape_sequence
          $$ = _parse_hexadecimal_escape_sequence();
          // <= hexadecimal_escape_sequence
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          // => universal_character_name
          $$ = _parse_universal_character_name();
          // <= universal_character_name
          _startPos = startPos4;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: escape_sequence
      _failure(_expect18);
    }
    // <= simple_escape_sequence / octal_escape_sequence / hexadecimal_escape_sequence / universal_character_name # Choice
    if (_cacheable[32]) {
      _addToCache($$, pos, 32);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_exclusive_OR_expression() {
    // NONTERMINAL
    // exclusive_OR_expression <- AND_expression exclusive_OR_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(10);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => AND_expression exclusive_OR_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => AND_expression exclusive_OR_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => AND_expression
          $$ = _parse_AND_expression();
          // <= AND_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => exclusive_OR_expression1
          $$ = _parse_exclusive_OR_expression1();
          // <= exclusive_OR_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= AND_expression exclusive_OR_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= AND_expression exclusive_OR_expression1 # Choice
    if (_cacheable[10]) {
      _addToCache($$, pos, 10);
    }  
    return $$;
  }
  
  dynamic _parse_exclusive_OR_expression1() {
    // NONTERMINAL
    // exclusive_OR_expression1 <- XOR AND_expression exclusive_OR_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(47);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => XOR AND_expression exclusive_OR_expression1 / '' # Choice
    switch (_getState(_transitions20)) {
      // [\u0000-]] [_-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [^]
      case 1:
        while (true) {
          // => XOR AND_expression exclusive_OR_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => XOR
            $$ = _parse_XOR();
            // <= XOR
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => AND_expression
            $$ = _parse_AND_expression();
            // <= AND_expression
            if (!success) break;
            seq[1] = $$;
            // => exclusive_OR_expression1
            $$ = _parse_exclusive_OR_expression1();
            // <= exclusive_OR_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= XOR AND_expression exclusive_OR_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '^', null
      _failure(_expect31);
    }
    // <= XOR AND_expression exclusive_OR_expression1 / '' # Choice
    if (_cacheable[47]) {
      _addToCache($$, pos, 47);
    }  
    return $$;
  }
  
  dynamic _parse_exponent_part() {
    // MORPHEME
    // exponent_part <- 'e' sign? digit_sequence / 'E' sign? digit_sequence
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(115);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(56);    
    // => 'e' sign? digit_sequence / 'E' sign? digit_sequence # Choice
    switch (_getState(_transitions40)) {
      // [E]
      case 0:
        // => 'E' sign? digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'E'
          $$ = 'E';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= 'E'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => sign?
          var testing0 = _testing;
          _testing = _cursor;
          // => sign
          $$ = _parse_sign();
          // <= sign
          success = true; 
          _testing = testing0;
          // <= sign?
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= 'E' sign? digit_sequence # Sequence
        break;
      // [e]
      case 1:
        // => 'e' sign? digit_sequence # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'e'
          $$ = 'e';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= 'e'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => sign?
          var testing1 = _testing;
          _testing = _cursor;
          // => sign
          $$ = _parse_sign();
          // <= sign
          success = true; 
          _testing = testing1;
          // <= sign?
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'e' sign? digit_sequence # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: exponent_part
      _failure(_expect92);
    }
    // <= 'e' sign? digit_sequence / 'E' sign? digit_sequence # Choice
    if (_cacheable[115]) {
      _addToCache($$, pos, 115);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_expression() {
    // NONTERMINAL
    // expression <- assignment_expression expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(38);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => assignment_expression expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => assignment_expression expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => assignment_expression
          $$ = _parse_assignment_expression();
          // <= assignment_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => expression1
          $$ = _parse_expression1();
          // <= expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= assignment_expression expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= assignment_expression expression1 # Choice
    if (_cacheable[38]) {
      _addToCache($$, pos, 38);
    }  
    return $$;
  }
  
  dynamic _parse_expression1() {
    // NONTERMINAL
    // expression1 <- COMMA assignment_expression expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(40);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => COMMA assignment_expression expression1 / '' # Choice
    switch (_getState(_transitions13)) {
      // [\u0000-+] [--\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [,]
      case 1:
        while (true) {
          // => COMMA assignment_expression expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => COMMA
            $$ = _parse_COMMA();
            // <= COMMA
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => assignment_expression
            $$ = _parse_assignment_expression();
            // <= assignment_expression
            if (!success) break;
            seq[1] = $$;
            // => expression1
            $$ = _parse_expression1();
            // <= expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= COMMA assignment_expression expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ',', null
      _failure(_expect24);
    }
    // <= COMMA assignment_expression expression1 / '' # Choice
    if (_cacheable[40]) {
      _addToCache($$, pos, 40);
    }  
    return $$;
  }
  
  dynamic _parse_floating_constant() {
    // MORPHEME
    // floating_constant <- decimal_floating_constant / hexadecimal_floating_constant
    var $$;
    _beginToken(26);  
    // => decimal_floating_constant / hexadecimal_floating_constant # Choice
    switch (_getState(_transitions28)) {
      // [.]
      case 0:
        var startPos0 = _startPos;
        // => decimal_floating_constant
        $$ = _parse_decimal_floating_constant();
        // <= decimal_floating_constant
        _startPos = startPos0;
        break;
      // [0-9]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => decimal_floating_constant
          $$ = _parse_decimal_floating_constant();
          // <= decimal_floating_constant
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => hexadecimal_floating_constant
          $$ = _parse_hexadecimal_floating_constant();
          // <= hexadecimal_floating_constant
          _startPos = startPos2;
          break;
        }
        break;
      // [P] [p]
      case 2:
        var startPos3 = _startPos;
        // => hexadecimal_floating_constant
        $$ = _parse_hexadecimal_floating_constant();
        // <= hexadecimal_floating_constant
        _startPos = startPos3;
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: floating_constant
      _failure(_expect61);
    }
    // <= decimal_floating_constant / hexadecimal_floating_constant # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_floating_suffix() {
    // MORPHEME
    // floating_suffix <- [FLfl]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(116);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(57);    
    // => [FLfl] # Choice
    switch (_getState(_transitions41)) {
      // [F] [L] [f] [l]
      case 0:
        var startPos0 = _startPos;
        // => [FLfl]
        $$ = _matchMapping(70, 108, _mapping7);
        // <= [FLfl]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: floating_suffix
      _failure(_expect93);
    }
    // <= [FLfl] # Choice
    if (_cacheable[116]) {
      _addToCache($$, pos, 116);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_fractional_constant() {
    // MORPHEME
    // fractional_constant <- digit_sequence? '.' digit_sequence / digit_sequence '.'
    var $$;
    _beginToken(58);  
    // => digit_sequence? '.' digit_sequence / digit_sequence '.' # Choice
    switch (_getState(_transitions24)) {
      // [.]
      case 0:
        // => digit_sequence? '.' digit_sequence # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => digit_sequence?
          var testing0 = _testing;
          _testing = _cursor;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          success = true; 
          _testing = testing0;
          // <= digit_sequence?
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => '.'
          $$ = _matchChar(46, '.');
          // <= '.'
          if (!success) break;
          seq[1] = $$;
          // => digit_sequence
          $$ = _parse_digit_sequence();
          // <= digit_sequence
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= digit_sequence? '.' digit_sequence # Sequence
        break;
      // [0-9]
      case 1:
        while (true) {
          // => digit_sequence? '.' digit_sequence # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit_sequence?
            var testing1 = _testing;
            _testing = _cursor;
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            success = true; 
            _testing = testing1;
            // <= digit_sequence?
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= digit_sequence? '.' digit_sequence # Sequence
          if (success) break;
          // => digit_sequence '.' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit_sequence
            $$ = _parse_digit_sequence();
            // <= digit_sequence
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= digit_sequence '.' # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: fractional_constant
      _failure(_expect94);
    }
    // <= digit_sequence? '.' digit_sequence / digit_sequence '.' # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_group() {
    // NONTERMINAL
    // group <- group_part+
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(1);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => group_part+ # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        var startPos0 = _startPos;
        // => group_part+
        var testing0;
        for (var first = true, reps; ;) {  
          // => group_part  
          $$ = _parse_group_part();  
          // <= group_part  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= group_part+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #if, #ifdef, #ifndef
      _failure(_expect1);
    }
    // <= group_part+ # Choice
    if (_cacheable[1]) {
      _addToCache($$, pos, 1);
    }  
    return $$;
  }
  
  dynamic _parse_group_part() {
    // NONTERMINAL
    // group_part <- if_section control_line text_line '#' non_directive
    var $$;
    // => if_section control_line text_line '#' non_directive # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => if_section control_line text_line '#' non_directive # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => if_section
          $$ = _parse_if_section();
          // <= if_section
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          // => control_line
          $$ = _parse_control_line();
          // <= control_line
          if (!success) break;
          seq[1] = $$;
          // => text_line
          $$ = _parse_text_line();
          // <= text_line
          if (!success) break;
          seq[2] = $$;
          // => '#'
          $$ = _matchChar(35, '#');
          // <= '#'
          if (!success) break;
          seq[3] = $$;
          // => non_directive
          $$ = _parse_non_directive();
          // <= non_directive
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= if_section control_line text_line '#' non_directive # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #if, #ifdef, #ifndef
      _failure(_expect1);
    }
    // <= if_section control_line text_line '#' non_directive # Choice
    return $$;
  }
  
  dynamic _parse_hex_quad() {
    // MORPHEME
    // hex_quad <- hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(118);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(59);    
    // => hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Choice
    switch (_getState(_transitions29)) {
      // [0-a] [f]
      case 0:
        // => hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[2] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hex_quad
      _failure(_expect95);
    }
    // <= hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit # Choice
    if (_cacheable[118]) {
      _addToCache($$, pos, 118);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_constant() {
    // MORPHEME
    // hexadecimal_constant <- hexadecimal_prefix hexadecimal_digit hexadecimal_constant1
    var $$;
    _beginToken(7);  
    // => hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => hexadecimal_prefix
          $$ = _parse_hexadecimal_prefix();
          // <= hexadecimal_prefix
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_constant1
          $$ = _parse_hexadecimal_constant1();
          // <= hexadecimal_constant1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_constant
      _failure(_expect12);
    }
    // <= hexadecimal_prefix hexadecimal_digit hexadecimal_constant1 # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_constant1() {
    // MORPHEME
    // hexadecimal_constant1 <- hexadecimal_digit hexadecimal_constant1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(28);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(8);    
    // => hexadecimal_digit hexadecimal_constant1 / '' # Choice
    switch (_getState(_transitions9)) {
      // [\u0000-/] [b-e] [g-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-a] [f]
      case 1:
        while (true) {
          // => hexadecimal_digit hexadecimal_constant1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit
            $$ = _parse_hexadecimal_digit();
            // <= hexadecimal_digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hexadecimal_constant1
            $$ = _parse_hexadecimal_constant1();
            // <= hexadecimal_constant1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= hexadecimal_digit hexadecimal_constant1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_constant1
      _failure(_expect13);
    }
    // <= hexadecimal_digit hexadecimal_constant1 / '' # Choice
    if (_cacheable[28]) {
      _addToCache($$, pos, 28);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_digit() {
    // MORPHEME
    // hexadecimal_digit <- [0-af]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(79);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(27);    
    // => [0-af] # Choice
    switch (_getState(_transitions29)) {
      // [0-a] [f]
      case 0:
        var startPos0 = _startPos;
        // => [0-af]
        $$ = _matchMapping(48, 102, _mapping2);
        // <= [0-af]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_digit
      _failure(_expect62);
    }
    // <= [0-af] # Choice
    if (_cacheable[79]) {
      _addToCache($$, pos, 79);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_digit_sequence() {
    // MORPHEME
    // hexadecimal_digit_sequence <- hexadecimal_digit+
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(119);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(60);    
    // => hexadecimal_digit+ # Choice
    switch (_getState(_transitions29)) {
      // [0-a] [f]
      case 0:
        var startPos0 = _startPos;
        // => hexadecimal_digit+
        var testing0;
        for (var first = true, reps; ;) {  
          // => hexadecimal_digit  
          $$ = _parse_hexadecimal_digit();  
          // <= hexadecimal_digit  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= hexadecimal_digit+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_digit_sequence
      _failure(_expect96);
    }
    // <= hexadecimal_digit+ # Choice
    if (_cacheable[119]) {
      _addToCache($$, pos, 119);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_escape_sequence() {
    // MORPHEME
    // hexadecimal_escape_sequence <- '\\x' hexadecimal_digit hexadecimal_escape_sequence1
    var $$;
    _beginToken(13);  
    // => '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        // => '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '\\x'
          $$ = _matchString(_strings4, '\\x');
          // <= '\\x'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => hexadecimal_digit
          $$ = _parse_hexadecimal_digit();
          // <= hexadecimal_digit
          if (!success) break;
          seq[1] = $$;
          // => hexadecimal_escape_sequence1
          $$ = _parse_hexadecimal_escape_sequence1();
          // <= hexadecimal_escape_sequence1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '\x'
      _failure(_expect19);
    }
    // <= '\\x' hexadecimal_digit hexadecimal_escape_sequence1 # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_escape_sequence1() {
    // MORPHEME
    // hexadecimal_escape_sequence1 <- hexadecimal_digit hexadecimal_escape_sequence1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(34);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(14);    
    // => hexadecimal_digit hexadecimal_escape_sequence1 / '' # Choice
    switch (_getState(_transitions9)) {
      // [\u0000-/] [b-e] [g-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-a] [f]
      case 1:
        while (true) {
          // => hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit
            $$ = _parse_hexadecimal_digit();
            // <= hexadecimal_digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hexadecimal_escape_sequence1
            $$ = _parse_hexadecimal_escape_sequence1();
            // <= hexadecimal_escape_sequence1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= hexadecimal_digit hexadecimal_escape_sequence1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_escape_sequence1
      _failure(_expect20);
    }
    // <= hexadecimal_digit hexadecimal_escape_sequence1 / '' # Choice
    if (_cacheable[34]) {
      _addToCache($$, pos, 34);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_floating_constant() {
    // MORPHEME
    // hexadecimal_floating_constant <- hexadecimal_prefix hexadecimal_fractional_constant / binary_exponent_part floating_suffix? / hexadecimal_prefix hexadecimal_digit_sequence / binary_exponent_part floating_suffix?
    var $$;
    _beginToken(61);  
    // => hexadecimal_prefix hexadecimal_fractional_constant / binary_exponent_part floating_suffix? / hexadecimal_prefix hexadecimal_digit_sequence / binary_exponent_part floating_suffix? # Choice
    switch (_getState(_transitions42)) {
      // [0]
      case 0:
        while (true) {
          // => hexadecimal_prefix hexadecimal_fractional_constant # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_prefix
            $$ = _parse_hexadecimal_prefix();
            // <= hexadecimal_prefix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hexadecimal_fractional_constant
            $$ = _parse_hexadecimal_fractional_constant();
            // <= hexadecimal_fractional_constant
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= hexadecimal_prefix hexadecimal_fractional_constant # Sequence
          if (success) break;
          // => hexadecimal_prefix hexadecimal_digit_sequence # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_prefix
            $$ = _parse_hexadecimal_prefix();
            // <= hexadecimal_prefix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= hexadecimal_prefix hexadecimal_digit_sequence # Sequence
          break;
        }
        break;
      // [P] [p]
      case 1:
        while (true) {
          // => binary_exponent_part floating_suffix? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => binary_exponent_part
            $$ = _parse_binary_exponent_part();
            // <= binary_exponent_part
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => floating_suffix?
            var testing0 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing0;
            // <= floating_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= binary_exponent_part floating_suffix? # Sequence
          if (success) break;
          // => binary_exponent_part floating_suffix? # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => binary_exponent_part
            $$ = _parse_binary_exponent_part();
            // <= binary_exponent_part
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => floating_suffix?
            var testing1 = _testing;
            _testing = _cursor;
            // => floating_suffix
            $$ = _parse_floating_suffix();
            // <= floating_suffix
            success = true; 
            _testing = testing1;
            // <= floating_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= binary_exponent_part floating_suffix? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_floating_constant
      _failure(_expect97);
    }
    // <= hexadecimal_prefix hexadecimal_fractional_constant / binary_exponent_part floating_suffix? / hexadecimal_prefix hexadecimal_digit_sequence / binary_exponent_part floating_suffix? # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_fractional_constant() {
    // MORPHEME
    // hexadecimal_fractional_constant <- hexadecimal_digit_sequence? '.' / hexadecimal_digit_sequence / hexadecimal_digit_sequence '.'
    var $$;
    _beginToken(62);  
    // => hexadecimal_digit_sequence? '.' / hexadecimal_digit_sequence / hexadecimal_digit_sequence '.' # Choice
    switch (_getState(_transitions43)) {
      // [.]
      case 0:
        // => hexadecimal_digit_sequence? '.' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => hexadecimal_digit_sequence?
          var testing0 = _testing;
          _testing = _cursor;
          // => hexadecimal_digit_sequence
          $$ = _parse_hexadecimal_digit_sequence();
          // <= hexadecimal_digit_sequence
          success = true; 
          _testing = testing0;
          // <= hexadecimal_digit_sequence?
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => '.'
          $$ = _matchChar(46, '.');
          // <= '.'
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= hexadecimal_digit_sequence? '.' # Sequence
        break;
      // [0-a] [f]
      case 1:
        while (true) {
          // => hexadecimal_digit_sequence? '.' # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit_sequence?
            var testing1 = _testing;
            _testing = _cursor;
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            success = true; 
            _testing = testing1;
            // <= hexadecimal_digit_sequence?
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= hexadecimal_digit_sequence? '.' # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => hexadecimal_digit_sequence
          $$ = _parse_hexadecimal_digit_sequence();
          // <= hexadecimal_digit_sequence
          _startPos = startPos2;
          if (success) break;
          // => hexadecimal_digit_sequence '.' # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_digit_sequence
            $$ = _parse_hexadecimal_digit_sequence();
            // <= hexadecimal_digit_sequence
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => '.'
            $$ = _matchChar(46, '.');
            // <= '.'
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos3;
          // <= hexadecimal_digit_sequence '.' # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_fractional_constant
      _failure(_expect98);
    }
    // <= hexadecimal_digit_sequence? '.' / hexadecimal_digit_sequence / hexadecimal_digit_sequence '.' # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_hexadecimal_prefix() {
    // MORPHEME
    // hexadecimal_prefix <- '0x' / '0X'
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(80);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(28);    
    // => '0x' / '0X' # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => '0x'
          $$ = _matchString(_strings26, '0x');
          // <= '0x'
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => '0X'
          $$ = _matchString(_strings27, '0X');
          // <= '0X'
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: hexadecimal_prefix
      _failure(_expect63);
    }
    // <= '0x' / '0X' # Choice
    if (_cacheable[80]) {
      _addToCache($$, pos, 80);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_identifier() {
    // LEXEME & MORPHEME
    // identifier <- identifier_nondigit identifier1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(19);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(0);    
    // => identifier_nondigit identifier1 # Choice
    switch (_getState(_transitions3)) {
      // [-] [A-Z] [\\] [a-z]
      case 0:
        // => identifier_nondigit identifier1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => identifier_nondigit
          $$ = _parse_identifier_nondigit();
          // <= identifier_nondigit
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => identifier1
          $$ = _parse_identifier1();
          // <= identifier1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= identifier_nondigit identifier1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier
      _failure(_expect4);
    }
    // <= identifier_nondigit identifier1 # Choice
    if (_cacheable[19]) {
      _addToCache($$, pos, 19);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_identifier1() {
    // MORPHEME
    // identifier1 <- identifier_nondigit identifier1 / digit identifier1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(20);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(1);    
    // => identifier_nondigit identifier1 / digit identifier1 / '' # Choice
    switch (_getState(_transitions4)) {
      // [\u0000-,] [.-/] [:-@] [[] []-`] [{-\u0010ffff]
      // EOF
      case 0:
      case 4:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [-] [A-Z] [\\] [a-z]
      case 1:
        while (true) {
          // => identifier_nondigit identifier1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => identifier_nondigit
            $$ = _parse_identifier_nondigit();
            // <= identifier_nondigit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => identifier1
            $$ = _parse_identifier1();
            // <= identifier1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= identifier_nondigit identifier1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // [0-9]
      case 2:
        while (true) {
          // => digit identifier1 # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit
            $$ = _parse_digit();
            // <= digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => identifier1
            $$ = _parse_identifier1();
            // <= identifier1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos3;
          // <= digit identifier1 # Sequence
          if (success) break;
          var startPos4 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos4;
          break;
        }
        break;
      // No matches
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier1
      _failure(_expect5);
    }
    // <= identifier_nondigit identifier1 / digit identifier1 / '' # Choice
    if (_cacheable[20]) {
      _addToCache($$, pos, 20);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_identifier_nondigit() {
    // MORPHEME
    // identifier_nondigit <- nondigit / universal_character_name
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(81);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(29);    
    // => nondigit / universal_character_name # Choice
    switch (_getState(_transitions30)) {
      // [-] [A-Z] [a-z]
      case 0:
        var startPos0 = _startPos;
        // => nondigit
        $$ = _parse_nondigit();
        // <= nondigit
        _startPos = startPos0;
        break;
      // [\\]
      case 1:
        var startPos1 = _startPos;
        // => universal_character_name
        $$ = _parse_universal_character_name();
        // <= universal_character_name
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier_nondigit
      _failure(_expect64);
    }
    // <= nondigit / universal_character_name # Choice
    if (_cacheable[81]) {
      _addToCache($$, pos, 81);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_if_group() {
    // NONTERMINAL
    // if_group <- '#if' spaces constant_expression new_line group? / '#ifdef' spaces identifier new_line group? / '#ifndef' spaces identifier new_line group?
    var $$;
    // => '#if' spaces constant_expression new_line group? / '#ifdef' spaces identifier new_line group? / '#ifndef' spaces identifier new_line group? # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        while (true) {
          // => '#if' spaces constant_expression new_line group? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '#if'
            $$ = _matchString(_strings0, '#if');
            // <= '#if'
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => spaces
            $$ = _parse_spaces();
            // <= spaces
            if (!success) break;
            seq[1] = $$;
            // => constant_expression
            $$ = _parse_constant_expression();
            // <= constant_expression
            if (!success) break;
            seq[2] = $$;
            // => new_line
            $$ = _parse_new_line();
            // <= new_line
            if (!success) break;
            seq[3] = $$;
            // => group?
            var testing0 = _testing;
            _testing = _cursor;
            // => group
            $$ = _parse_group();
            // <= group
            success = true; 
            _testing = testing0;
            // <= group?
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '#if' spaces constant_expression new_line group? # Sequence
          if (success) break;
          // => '#ifdef' spaces identifier new_line group? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '#ifdef'
            $$ = _matchString(_strings1, '#ifdef');
            // <= '#ifdef'
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => spaces
            $$ = _parse_spaces();
            // <= spaces
            if (!success) break;
            seq[1] = $$;
            // => identifier
            $$ = _parse_identifier();
            // <= identifier
            if (!success) break;
            seq[2] = $$;
            // => new_line
            $$ = _parse_new_line();
            // <= new_line
            if (!success) break;
            seq[3] = $$;
            // => group?
            var testing1 = _testing;
            _testing = _cursor;
            // => group
            $$ = _parse_group();
            // <= group
            success = true; 
            _testing = testing1;
            // <= group?
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '#ifdef' spaces identifier new_line group? # Sequence
          if (success) break;
          // => '#ifndef' spaces identifier new_line group? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '#ifndef'
            $$ = _matchString(_strings2, '#ifndef');
            // <= '#ifndef'
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            // => spaces
            $$ = _parse_spaces();
            // <= spaces
            if (!success) break;
            seq[1] = $$;
            // => identifier
            $$ = _parse_identifier();
            // <= identifier
            if (!success) break;
            seq[2] = $$;
            // => new_line
            $$ = _parse_new_line();
            // <= new_line
            if (!success) break;
            seq[3] = $$;
            // => group?
            var testing2 = _testing;
            _testing = _cursor;
            // => group
            $$ = _parse_group();
            // <= group
            success = true; 
            _testing = testing2;
            // <= group?
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= '#ifndef' spaces identifier new_line group? # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #if, #ifdef, #ifndef
      _failure(_expect1);
    }
    // <= '#if' spaces constant_expression new_line group? / '#ifdef' spaces identifier new_line group? / '#ifndef' spaces identifier new_line group? # Choice
    return $$;
  }
  
  dynamic _parse_if_section() {
    // NONTERMINAL
    // if_section <- if_group elif_groups? else_group? endif_line
    var $$;
    // => if_group elif_groups? else_group? endif_line # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => if_group elif_groups? else_group? endif_line # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => if_group
          $$ = _parse_if_group();
          // <= if_group
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          // => elif_groups?
          var testing0 = _testing;
          _testing = _cursor;
          // => elif_groups
          $$ = _parse_elif_groups();
          // <= elif_groups
          success = true; 
          _testing = testing0;
          // <= elif_groups?
          if (!success) break;
          seq[1] = $$;
          // => else_group?
          var testing1 = _testing;
          _testing = _cursor;
          // => else_group
          $$ = _parse_else_group();
          // <= else_group
          success = true; 
          _testing = testing1;
          // <= else_group?
          if (!success) break;
          seq[2] = $$;
          // => endif_line
          $$ = _parse_endif_line();
          // <= endif_line
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= if_group elif_groups? else_group? endif_line # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: #if, #ifdef, #ifndef
      _failure(_expect1);
    }
    // <= if_group elif_groups? else_group? endif_line # Choice
    return $$;
  }
  
  dynamic _parse_inclusive_OR_expression() {
    // NONTERMINAL
    // inclusive_OR_expression <- exclusive_OR_expression inclusive_OR_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(9);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => exclusive_OR_expression inclusive_OR_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => exclusive_OR_expression inclusive_OR_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => exclusive_OR_expression
          $$ = _parse_exclusive_OR_expression();
          // <= exclusive_OR_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => inclusive_OR_expression1
          $$ = _parse_inclusive_OR_expression1();
          // <= inclusive_OR_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= exclusive_OR_expression inclusive_OR_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= exclusive_OR_expression inclusive_OR_expression1 # Choice
    if (_cacheable[9]) {
      _addToCache($$, pos, 9);
    }  
    return $$;
  }
  
  dynamic _parse_inclusive_OR_expression1() {
    // NONTERMINAL
    // inclusive_OR_expression1 <- OR1 exclusive_OR_expression inclusive_OR_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(48);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => OR1 exclusive_OR_expression inclusive_OR_expression1 / '' # Choice
    switch (_getState(_transitions21)) {
      // [\u0000-{] [}-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [|]
      case 1:
        while (true) {
          // => OR1 exclusive_OR_expression inclusive_OR_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => OR1
            $$ = _parse_OR1();
            // <= OR1
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => exclusive_OR_expression
            $$ = _parse_exclusive_OR_expression();
            // <= exclusive_OR_expression
            if (!success) break;
            seq[1] = $$;
            // => inclusive_OR_expression1
            $$ = _parse_inclusive_OR_expression1();
            // <= inclusive_OR_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= OR1 exclusive_OR_expression inclusive_OR_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '|', null
      _failure(_expect32);
    }
    // <= OR1 exclusive_OR_expression inclusive_OR_expression1 / '' # Choice
    if (_cacheable[48]) {
      _addToCache($$, pos, 48);
    }  
    return $$;
  }
  
  dynamic _parse_integer_constant() {
    // MORPHEME
    // integer_constant <- decimal_constant integer_suffix? / octal_constant integer_suffix? / hexadecimal_constant integer_suffix?
    var $$;
    _beginToken(2);  
    // => decimal_constant integer_suffix? / octal_constant integer_suffix? / hexadecimal_constant integer_suffix? # Choice
    switch (_getState(_transitions6)) {
      // [0]
      case 0:
        while (true) {
          // => octal_constant integer_suffix? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => octal_constant
            $$ = _parse_octal_constant();
            // <= octal_constant
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => integer_suffix?
            var testing0 = _testing;
            _testing = _cursor;
            // => integer_suffix
            $$ = _parse_integer_suffix();
            // <= integer_suffix
            success = true; 
            _testing = testing0;
            // <= integer_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= octal_constant integer_suffix? # Sequence
          if (success) break;
          // => hexadecimal_constant integer_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => hexadecimal_constant
            $$ = _parse_hexadecimal_constant();
            // <= hexadecimal_constant
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => integer_suffix?
            var testing1 = _testing;
            _testing = _cursor;
            // => integer_suffix
            $$ = _parse_integer_suffix();
            // <= integer_suffix
            success = true; 
            _testing = testing1;
            // <= integer_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= hexadecimal_constant integer_suffix? # Sequence
          break;
        }
        break;
      // [1-9]
      case 1:
        // => decimal_constant integer_suffix? # Sequence
        var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => decimal_constant
          $$ = _parse_decimal_constant();
          // <= decimal_constant
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => integer_suffix?
          var testing2 = _testing;
          _testing = _cursor;
          // => integer_suffix
          $$ = _parse_integer_suffix();
          // <= integer_suffix
          success = true; 
          _testing = testing2;
          // <= integer_suffix?
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos2;
        // <= decimal_constant integer_suffix? # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: integer_constant
      _failure(_expect7);
    }
    // <= decimal_constant integer_suffix? / octal_constant integer_suffix? / hexadecimal_constant integer_suffix? # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_integer_suffix() {
    // MORPHEME
    // integer_suffix <- unsigned_suffix long_suffix? / unsigned_suffix long_long_suffix / long_suffix unsigned_suffix? / long_long_suffix unsigned_suffix?
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(82);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(30);    
    // => unsigned_suffix long_suffix? / unsigned_suffix long_long_suffix / long_suffix unsigned_suffix? / long_long_suffix unsigned_suffix? # Choice
    switch (_getState(_transitions31)) {
      // [L] [l]
      case 0:
        while (true) {
          // => long_suffix unsigned_suffix? # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => long_suffix
            $$ = _parse_long_suffix();
            // <= long_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => unsigned_suffix?
            var testing0 = _testing;
            _testing = _cursor;
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            success = true; 
            _testing = testing0;
            // <= unsigned_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= long_suffix unsigned_suffix? # Sequence
          if (success) break;
          // => long_long_suffix unsigned_suffix? # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => long_long_suffix
            $$ = _parse_long_long_suffix();
            // <= long_long_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => unsigned_suffix?
            var testing1 = _testing;
            _testing = _cursor;
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            success = true; 
            _testing = testing1;
            // <= unsigned_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= long_long_suffix unsigned_suffix? # Sequence
          break;
        }
        break;
      // [U] [u]
      case 1:
        while (true) {
          // => unsigned_suffix long_suffix? # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => long_suffix?
            var testing2 = _testing;
            _testing = _cursor;
            // => long_suffix
            $$ = _parse_long_suffix();
            // <= long_suffix
            success = true; 
            _testing = testing2;
            // <= long_suffix?
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= unsigned_suffix long_suffix? # Sequence
          if (success) break;
          // => unsigned_suffix long_long_suffix # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => unsigned_suffix
            $$ = _parse_unsigned_suffix();
            // <= unsigned_suffix
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => long_long_suffix
            $$ = _parse_long_long_suffix();
            // <= long_long_suffix
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          // <= unsigned_suffix long_long_suffix # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: integer_suffix
      _failure(_expect65);
    }
    // <= unsigned_suffix long_suffix? / unsigned_suffix long_long_suffix / long_suffix unsigned_suffix? / long_long_suffix unsigned_suffix? # Choice
    if (_cacheable[82]) {
      _addToCache($$, pos, 82);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_logical_AND_expression() {
    // NONTERMINAL
    // logical_AND_expression <- inclusive_OR_expression logical_AND_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(8);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => inclusive_OR_expression logical_AND_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => inclusive_OR_expression logical_AND_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => inclusive_OR_expression
          $$ = _parse_inclusive_OR_expression();
          // <= inclusive_OR_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => logical_AND_expression1
          $$ = _parse_logical_AND_expression1();
          // <= logical_AND_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= inclusive_OR_expression logical_AND_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= inclusive_OR_expression logical_AND_expression1 # Choice
    if (_cacheable[8]) {
      _addToCache($$, pos, 8);
    }  
    return $$;
  }
  
  dynamic _parse_logical_AND_expression1() {
    // NONTERMINAL
    // logical_AND_expression1 <- AND2 inclusive_OR_expression logical_AND_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(49);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => AND2 inclusive_OR_expression logical_AND_expression1 / '' # Choice
    switch (_getState(_transitions19)) {
      // [\u0000-%] [\'-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [&]
      case 1:
        while (true) {
          // => AND2 inclusive_OR_expression logical_AND_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => AND2
            $$ = _parse_AND2();
            // <= AND2
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => inclusive_OR_expression
            $$ = _parse_inclusive_OR_expression();
            // <= inclusive_OR_expression
            if (!success) break;
            seq[1] = $$;
            // => logical_AND_expression1
            $$ = _parse_logical_AND_expression1();
            // <= logical_AND_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= AND2 inclusive_OR_expression logical_AND_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '&&', null
      _failure(_expect33);
    }
    // <= AND2 inclusive_OR_expression logical_AND_expression1 / '' # Choice
    if (_cacheable[49]) {
      _addToCache($$, pos, 49);
    }  
    return $$;
  }
  
  dynamic _parse_logical_OR_expression() {
    // NONTERMINAL
    // logical_OR_expression <- logical_AND_expression logical_OR_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(7);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => logical_AND_expression logical_OR_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => logical_AND_expression logical_OR_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => logical_AND_expression
          $$ = _parse_logical_AND_expression();
          // <= logical_AND_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => logical_OR_expression1
          $$ = _parse_logical_OR_expression1();
          // <= logical_OR_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= logical_AND_expression logical_OR_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= logical_AND_expression logical_OR_expression1 # Choice
    if (_cacheable[7]) {
      _addToCache($$, pos, 7);
    }  
    return $$;
  }
  
  dynamic _parse_logical_OR_expression1() {
    // NONTERMINAL
    // logical_OR_expression1 <- OR2 logical_AND_expression logical_OR_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(50);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => OR2 logical_AND_expression logical_OR_expression1 / '' # Choice
    switch (_getState(_transitions21)) {
      // [\u0000-{] [}-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [|]
      case 1:
        while (true) {
          // => OR2 logical_AND_expression logical_OR_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => OR2
            $$ = _parse_OR2();
            // <= OR2
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => logical_AND_expression
            $$ = _parse_logical_AND_expression();
            // <= logical_AND_expression
            if (!success) break;
            seq[1] = $$;
            // => logical_OR_expression1
            $$ = _parse_logical_OR_expression1();
            // <= logical_OR_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= OR2 logical_AND_expression logical_OR_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '||', null
      _failure(_expect34);
    }
    // <= OR2 logical_AND_expression logical_OR_expression1 / '' # Choice
    if (_cacheable[50]) {
      _addToCache($$, pos, 50);
    }  
    return $$;
  }
  
  dynamic _parse_long_long_suffix() {
    // MORPHEME
    // long_long_suffix <- 'll' / 'LL'
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(122);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(63);    
    // => 'll' / 'LL' # Choice
    switch (_getState(_transitions44)) {
      // [L]
      case 0:
        var startPos0 = _startPos;
        // => 'LL'
        $$ = _matchString(_strings34, 'LL');
        // <= 'LL'
        _startPos = startPos0;
        break;
      // [l]
      case 1:
        var startPos1 = _startPos;
        // => 'll'
        $$ = _matchString(_strings35, 'll');
        // <= 'll'
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: long_long_suffix
      _failure(_expect99);
    }
    // <= 'll' / 'LL' # Choice
    if (_cacheable[122]) {
      _addToCache($$, pos, 122);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_long_suffix() {
    // MORPHEME
    // long_suffix <- [Ll]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(123);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(64);    
    // => [Ll] # Choice
    switch (_getState(_transitions45)) {
      // [L] [l]
      case 0:
        var startPos0 = _startPos;
        // => [Ll]
        $$ = _matchMapping(76, 108, _mapping8);
        // <= [Ll]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: long_suffix
      _failure(_expect100);
    }
    // <= [Ll] # Choice
    if (_cacheable[123]) {
      _addToCache($$, pos, 123);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_lparen() {
    // LEXEME
    // lparen <- '(' spaces
    var $$;
    // => '(' spaces # Choice
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      // [(]
      case 0:
        // => '(' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '('
          $$ = '(';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '('
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '(' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '('
      _failure(_expect66);
    }
    // <= '(' spaces # Choice
    return $$;
  }
  
  dynamic _parse_multiplicative_expression() {
    // NONTERMINAL
    // multiplicative_expression <- unary_expression multiplicative_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(16);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => unary_expression multiplicative_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => unary_expression multiplicative_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => unary_expression
          $$ = _parse_unary_expression();
          // <= unary_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => multiplicative_expression1
          $$ = _parse_multiplicative_expression1();
          // <= multiplicative_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= unary_expression multiplicative_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= unary_expression multiplicative_expression1 # Choice
    if (_cacheable[16]) {
      _addToCache($$, pos, 16);
    }  
    return $$;
  }
  
  dynamic _parse_multiplicative_expression1() {
    // NONTERMINAL
    // multiplicative_expression1 <- multiplicative_operator unary_expression multiplicative_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(41);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => multiplicative_operator unary_expression multiplicative_expression1 / '' # Choice
    switch (_getState(_transitions14)) {
      // [\u0000-\$] [&-)] [+-.] [0-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [%] [*] [/]
      case 1:
        while (true) {
          // => multiplicative_operator unary_expression multiplicative_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => multiplicative_operator
            $$ = _parse_multiplicative_operator();
            // <= multiplicative_operator
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => unary_expression
            $$ = _parse_unary_expression();
            // <= unary_expression
            if (!success) break;
            seq[1] = $$;
            // => multiplicative_expression1
            $$ = _parse_multiplicative_expression1();
            // <= multiplicative_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= multiplicative_operator unary_expression multiplicative_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: multiplicative_operator, null
      _failure(_expect25);
    }
    // <= multiplicative_operator unary_expression multiplicative_expression1 / '' # Choice
    if (_cacheable[41]) {
      _addToCache($$, pos, 41);
    }  
    return $$;
  }
  
  dynamic _parse_multiplicative_operator() {
    // LEXEME
    // multiplicative_operator <- ASTERISK / SLASH / PERCENT
    var $$;
    // => ASTERISK / SLASH / PERCENT # Choice
    switch (_getState(_transitions32)) {
      // [%]
      case 0:
        var startPos0 = _startPos;
        // => PERCENT
        $$ = _parse_PERCENT();
        // <= PERCENT
        _startPos = startPos0;
        break;
      // [*]
      case 1:
        var startPos1 = _startPos;
        // => ASTERISK
        $$ = _parse_ASTERISK();
        // <= ASTERISK
        _startPos = startPos1;
        break;
      // [/]
      case 2:
        var startPos2 = _startPos;
        // => SLASH
        $$ = _parse_SLASH();
        // <= SLASH
        _startPos = startPos2;
        break;
      // No matches
      // EOF
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: multiplicative_operator
      _failure(_expect67);
    }
    // <= ASTERISK / SLASH / PERCENT # Choice
    return $$;
  }
  
  dynamic _parse_new_line() {
    // LEXEME & MORPHEME
    // new_line <- '\r\n' / [\n\r]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(85);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(31);    
    // => '\r\n' / [\n\r] # Choice
    switch (_getState(_transitions33)) {
      // [\n]
      case 0:
        var startPos0 = _startPos;
        // => [\n\r]
        $$ = _matchMapping(10, 13, _mapping3);
        // <= [\n\r]
        _startPos = startPos0;
        break;
      // [\r]
      case 1:
        while (true) {
          var startPos1 = _startPos;
          // => '\r\n'
          $$ = _matchString(_strings28, '\r\n');
          // <= '\r\n'
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          // => [\n\r]
          $$ = _matchMapping(10, 13, _mapping3);
          // <= [\n\r]
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: new_line
      _failure(_expect68);
    }
    // <= '\r\n' / [\n\r] # Choice
    if (_cacheable[85]) {
      _addToCache($$, pos, 85);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_non_directive() {
    // LEXEME
    // non_directive <- pp_tokens new_line
    var $$;
    // => pp_tokens new_line # Choice
    switch (_getState(_transitions22)) {
      // [!-?] [A-]] [a-{] [}-~]
      case 0:
        // => pp_tokens new_line # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => pp_tokens
          $$ = _parse_pp_tokens();
          // <= pp_tokens
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= pp_tokens new_line # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: non_directive
      _failure(_expect46);
    }
    // <= pp_tokens new_line # Choice
    return $$;
  }
  
  dynamic _parse_nondigit() {
    // MORPHEME
    // nondigit <- [\-A-Za-z]
    var $$;
    _beginToken(65);  
    // => [\-A-Za-z] # Choice
    switch (_getState(_transitions46)) {
      // [-] [A-Z] [a-z]
      case 0:
        var startPos0 = _startPos;
        // => [\-A-Za-z]
        $$ = _matchMapping(45, 122, _mapping9);
        // <= [\-A-Za-z]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: nondigit
      _failure(_expect101);
    }
    // <= [\-A-Za-z] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_nonzero_digit() {
    // MORPHEME
    // nonzero_digit <- [1-9]
    var $$;
    _beginToken(32);  
    // => [1-9] # Choice
    switch (_ch >= 49 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      // [1-9]
      case 0:
        var startPos0 = _startPos;
        // => [1-9]
        $$ = _matchRange(49, 57);
        // <= [1-9]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: nonzero_digit
      _failure(_expect69);
    }
    // <= [1-9] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_octal_constant() {
    // MORPHEME
    // octal_constant <- '0' octal_constant1
    var $$;
    _beginToken(5);  
    // => '0' octal_constant1 # Choice
    switch (_ch == 48 ? 0 : _ch == -1 ? 2 : 1) {
      // [0]
      case 0:
        // => '0' octal_constant1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '0'
          $$ = '0';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '0'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => octal_constant1
          $$ = _parse_octal_constant1();
          // <= octal_constant1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '0' octal_constant1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '0'
      _failure(_expect10);
    }
    // <= '0' octal_constant1 # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_octal_constant1() {
    // MORPHEME
    // octal_constant1 <- octal_digit octal_constant1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(26);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(6);    
    // => octal_digit octal_constant1 / '' # Choice
    switch (_getState(_transitions8)) {
      // [\u0000-/] [8-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [0-7]
      case 1:
        while (true) {
          // => octal_digit octal_constant1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => octal_constant1
            $$ = _parse_octal_constant1();
            // <= octal_constant1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= octal_digit octal_constant1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: octal_constant1
      _failure(_expect11);
    }
    // <= octal_digit octal_constant1 / '' # Choice
    if (_cacheable[26]) {
      _addToCache($$, pos, 26);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_octal_digit() {
    // MORPHEME
    // octal_digit <- [0-7]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(87);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(33);    
    // => [0-7] # Choice
    switch (_ch >= 48 && _ch <= 55 ? 0 : _ch == -1 ? 2 : 1) {
      // [0-7]
      case 0:
        var startPos0 = _startPos;
        // => [0-7]
        $$ = _matchRange(48, 55);
        // <= [0-7]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: octal_digit
      _failure(_expect70);
    }
    // <= [0-7] # Choice
    if (_cacheable[87]) {
      _addToCache($$, pos, 87);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_octal_escape_sequence() {
    // MORPHEME
    // octal_escape_sequence <- '\\' octal_digit / '\\' octal_digit octal_digit / '\\' octal_digit octal_digit octal_digit
    var $$;
    _beginToken(34);  
    // => '\\' octal_digit / '\\' octal_digit octal_digit / '\\' octal_digit octal_digit octal_digit # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\' octal_digit # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\' octal_digit # Sequence
          if (success) break;
          // => '\\' octal_digit octal_digit # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[1] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\' octal_digit octal_digit # Sequence
          if (success) break;
          // => '\\' octal_digit octal_digit octal_digit # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\'
            $$ = '\\';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '\\'
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[1] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[2] = $$;
            // => octal_digit
            $$ = _parse_octal_digit();
            // <= octal_digit
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          // <= '\\' octal_digit octal_digit octal_digit # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '\'
      _failure(_expect71);
    }
    // <= '\\' octal_digit / '\\' octal_digit octal_digit / '\\' octal_digit octal_digit octal_digit # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_pp_number() {
    // MORPHEME
    // pp_number <- digit pp_number1 / '.' digit pp_number1
    var $$;
    _beginToken(21);  
    // => digit pp_number1 / '.' digit pp_number1 # Choice
    switch (_getState(_transitions24)) {
      // [.]
      case 0:
        // => '.' digit pp_number1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '.'
          $$ = '.';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '.'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => digit
          $$ = _parse_digit();
          // <= digit
          if (!success) break;
          seq[1] = $$;
          // => pp_number1
          $$ = _parse_pp_number1();
          // <= pp_number1
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '.' digit pp_number1 # Sequence
        break;
      // [0-9]
      case 1:
        // => digit pp_number1 # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => digit
          $$ = _parse_digit();
          // <= digit
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => pp_number1
          $$ = _parse_pp_number1();
          // <= pp_number1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= digit pp_number1 # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: pp_number
      _failure(_expect41);
    }
    // <= digit pp_number1 / '.' digit pp_number1 # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_pp_number1() {
    // MORPHEME
    // pp_number1 <- digit pp_number1 / identifier_nondigit pp_number1 / 'e' sign pp_number1 / 'E' sign pp_number1 / 'p' sign pp_number1 / 'P' sign pp_number1 / '.' pp_number1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(59);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(22);    
    // => digit pp_number1 / identifier_nondigit pp_number1 / 'e' sign pp_number1 / 'E' sign pp_number1 / 'p' sign pp_number1 / 'P' sign pp_number1 / '.' pp_number1 / '' # Choice
    switch (_getState(_transitions25)) {
      // [\u0000-,] [/] [:-@] [[] []-`] [{-\u0010ffff]
      // EOF
      case 0:
      case 7:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [-] [\\]
      case 1:
        while (true) {
          // => identifier_nondigit pp_number1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => identifier_nondigit
            $$ = _parse_identifier_nondigit();
            // <= identifier_nondigit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= identifier_nondigit pp_number1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // [.]
      case 2:
        while (true) {
          // => '.' pp_number1 # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '.'
            $$ = '.';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= '.'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos3;
          // <= '.' pp_number1 # Sequence
          if (success) break;
          var startPos4 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos4;
          break;
        }
        break;
      // [0-9]
      case 3:
        while (true) {
          // => digit pp_number1 # Sequence
          var ch2 = _ch, pos2 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => digit
            $$ = _parse_digit();
            // <= digit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos5;
          // <= digit pp_number1 # Sequence
          if (success) break;
          var startPos6 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos6;
          break;
        }
        break;
      // [A-Z]
      case 4:
        while (true) {
          // => identifier_nondigit pp_number1 # Sequence
          var ch3 = _ch, pos3 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => identifier_nondigit
            $$ = _parse_identifier_nondigit();
            // <= identifier_nondigit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos7;
          // <= identifier_nondigit pp_number1 # Sequence
          if (success) break;
          // => 'E' sign pp_number1 # Sequence
          var ch4 = _ch, pos4 = _cursor, startPos8 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => 'E'
            $$ = 'E';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= 'E'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => sign
            $$ = _parse_sign();
            // <= sign
            if (!success) break;
            seq[1] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos8;
          // <= 'E' sign pp_number1 # Sequence
          if (success) break;
          // => 'P' sign pp_number1 # Sequence
          var ch5 = _ch, pos5 = _cursor, startPos9 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => 'P'
            $$ = 'P';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= 'P'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => sign
            $$ = _parse_sign();
            // <= sign
            if (!success) break;
            seq[1] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos9;
          // <= 'P' sign pp_number1 # Sequence
          if (success) break;
          var startPos10 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos10;
          break;
        }
        break;
      // [a-z]
      case 5:
        while (true) {
          // => identifier_nondigit pp_number1 # Sequence
          var ch6 = _ch, pos6 = _cursor, startPos11 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => identifier_nondigit
            $$ = _parse_identifier_nondigit();
            // <= identifier_nondigit
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos11;
          // <= identifier_nondigit pp_number1 # Sequence
          if (success) break;
          // => 'e' sign pp_number1 # Sequence
          var ch7 = _ch, pos7 = _cursor, startPos12 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => 'e'
            $$ = 'e';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= 'e'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => sign
            $$ = _parse_sign();
            // <= sign
            if (!success) break;
            seq[1] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch7;
            _cursor = pos7;
          }
          _startPos = startPos12;
          // <= 'e' sign pp_number1 # Sequence
          if (success) break;
          // => 'p' sign pp_number1 # Sequence
          var ch8 = _ch, pos8 = _cursor, startPos13 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => 'p'
            $$ = 'p';
            success = true;
            if (++_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            // <= 'p'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => sign
            $$ = _parse_sign();
            // <= sign
            if (!success) break;
            seq[1] = $$;
            // => pp_number1
            $$ = _parse_pp_number1();
            // <= pp_number1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch8;
            _cursor = pos8;
          }
          _startPos = startPos13;
          // <= 'p' sign pp_number1 # Sequence
          if (success) break;
          var startPos14 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos14;
          break;
        }
        break;
      // No matches
      case 6:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: pp_number1
      _failure(_expect42);
    }
    // <= digit pp_number1 / identifier_nondigit pp_number1 / 'e' sign pp_number1 / 'E' sign pp_number1 / 'p' sign pp_number1 / 'P' sign pp_number1 / '.' pp_number1 / '' # Choice
    if (_cacheable[59]) {
      _addToCache($$, pos, 59);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_pp_tokens() {
    // MORPHEME
    // pp_tokens <- preprocessing_token+
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(56);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(19);    
    // => preprocessing_token+ # Choice
    switch (_getState(_transitions22)) {
      // [!-?] [A-]] [a-{] [}-~]
      case 0:
        var startPos0 = _startPos;
        // => preprocessing_token+
        var testing0;
        for (var first = true, reps; ;) {  
          // => preprocessing_token  
          $$ = _parse_preprocessing_token();  
          // <= preprocessing_token  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= preprocessing_token+
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: pp_tokens
      _failure(_expect39);
    }
    // <= preprocessing_token+ # Choice
    if (_cacheable[56]) {
      _addToCache($$, pos, 56);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_preprocessing_token() {
    // MORPHEME
    // preprocessing_token <- identifier / pp_number / character_constant / string_literal / punctuator
    var $$;
    _beginToken(20);  
    // => identifier / pp_number / character_constant / string_literal / punctuator # Choice
    switch (_getState(_transitions23)) {
      // [!] [#-&] [(-,] [/] [:-?] [[] []] [{] [}-~]
      case 0:
        var startPos0 = _startPos;
        // => punctuator
        $$ = _parse_punctuator();
        // <= punctuator
        _startPos = startPos0;
        break;
      // [\"]
      case 1:
        var startPos1 = _startPos;
        // => string_literal
        $$ = _parse_string_literal();
        // <= string_literal
        _startPos = startPos1;
        break;
      // [\']
      case 2:
        var startPos2 = _startPos;
        // => character_constant
        $$ = _parse_character_constant();
        // <= character_constant
        _startPos = startPos2;
        break;
      // [-]
      case 3:
        while (true) {
          var startPos3 = _startPos;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          // => punctuator
          $$ = _parse_punctuator();
          // <= punctuator
          _startPos = startPos4;
          break;
        }
        break;
      // [.]
      case 4:
        while (true) {
          var startPos5 = _startPos;
          // => pp_number
          $$ = _parse_pp_number();
          // <= pp_number
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          // => punctuator
          $$ = _parse_punctuator();
          // <= punctuator
          _startPos = startPos6;
          break;
        }
        break;
      // [0-9]
      case 5:
        var startPos7 = _startPos;
        // => pp_number
        $$ = _parse_pp_number();
        // <= pp_number
        _startPos = startPos7;
        break;
      // [A-Z]
      case 6:
        while (true) {
          var startPos8 = _startPos;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          _startPos = startPos8;
          if (success) break;
          var startPos9 = _startPos;
          // => character_constant
          $$ = _parse_character_constant();
          // <= character_constant
          _startPos = startPos9;
          if (success) break;
          var startPos10 = _startPos;
          // => string_literal
          $$ = _parse_string_literal();
          // <= string_literal
          _startPos = startPos10;
          break;
        }
        break;
      // [\\] [a-z]
      case 7:
        var startPos11 = _startPos;
        // => identifier
        $$ = _parse_identifier();
        // <= identifier
        _startPos = startPos11;
        break;
      // No matches
      // EOF
      case 8:
      case 9:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: preprocessing_token
      _failure(_expect40);
    }
    // <= identifier / pp_number / character_constant / string_literal / punctuator # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_primary_expression() {
    // NONTERMINAL
    // primary_expression <- identifier / constant / string_literal / lparen expression rparen
    var $$;
    // => identifier / constant / string_literal / lparen expression rparen # Choice
    switch (_getState(_transitions2)) {
      // [\"]
      case 0:
        var startPos0 = _startPos;
        // => string_literal
        $$ = _parse_string_literal();
        // <= string_literal
        _startPos = startPos0;
        break;
      // [\'] [.] [0-9]
      case 1:
        var startPos1 = _startPos;
        // => constant
        $$ = _parse_constant();
        // <= constant
        _startPos = startPos1;
        break;
      // [(]
      case 2:
        // => lparen expression rparen # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => lparen
          $$ = _parse_lparen();
          // <= lparen
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => expression
          $$ = _parse_expression();
          // <= expression
          if (!success) break;
          seq[1] = $$;
          // => rparen
          $$ = _parse_rparen();
          // <= rparen
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos2;
        // <= lparen expression rparen # Sequence
        break;
      // [-] [\\]
      case 3:
        var startPos3 = _startPos;
        // => identifier
        $$ = _parse_identifier();
        // <= identifier
        _startPos = startPos3;
        break;
      // [A-Z]
      case 4:
        while (true) {
          var startPos4 = _startPos;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          // => constant
          $$ = _parse_constant();
          // <= constant
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          // => string_literal
          $$ = _parse_string_literal();
          // <= string_literal
          _startPos = startPos6;
          break;
        }
        break;
      // [a-z]
      case 5:
        while (true) {
          var startPos7 = _startPos;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          _startPos = startPos7;
          if (success) break;
          var startPos8 = _startPos;
          // => constant
          $$ = _parse_constant();
          // <= constant
          _startPos = startPos8;
          break;
        }
        break;
      // No matches
      // EOF
      case 6:
      case 7:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '('
      _failure(_expect3);
    }
    // <= identifier / constant / string_literal / lparen expression rparen # Choice
    return $$;
  }
  
  dynamic _parse_punctuator() {
    // MORPHEME
    // punctuator <- [!#-&(-/:-?\[\]{}-~]
    var $$;
    _beginToken(35);  
    // => [!#-&(-/:-?\[\]{}-~] # Choice
    switch (_getState(_transitions34)) {
      // [!] [#-&] [(-/] [:-?] [[] []] [{] [}-~]
      case 0:
        var startPos0 = _startPos;
        // => [!#-&(-/:-?\[\]{}-~]
        $$ = _matchMapping(33, 126, _mapping4);
        // <= [!#-&(-/:-?\[\]{}-~]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: punctuator
      _failure(_expect72);
    }
    // <= [!#-&(-/:-?\[\]{}-~] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_relational_expression() {
    // NONTERMINAL
    // relational_expression <- shift_expression relational_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(13);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => shift_expression relational_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => shift_expression relational_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => shift_expression
          $$ = _parse_shift_expression();
          // <= shift_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => relational_expression1
          $$ = _parse_relational_expression1();
          // <= relational_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= shift_expression relational_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= shift_expression relational_expression1 # Choice
    if (_cacheable[13]) {
      _addToCache($$, pos, 13);
    }  
    return $$;
  }
  
  dynamic _parse_relational_expression1() {
    // NONTERMINAL
    // relational_expression1 <- relational_operator shift_expression relational_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(44);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => relational_operator shift_expression relational_expression1 / '' # Choice
    switch (_getState(_transitions17)) {
      // [\u0000-;] [=] [?-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [<] [>]
      case 1:
        while (true) {
          // => relational_operator shift_expression relational_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => relational_operator
            $$ = _parse_relational_operator();
            // <= relational_operator
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => shift_expression
            $$ = _parse_shift_expression();
            // <= shift_expression
            if (!success) break;
            seq[1] = $$;
            // => relational_expression1
            $$ = _parse_relational_expression1();
            // <= relational_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= relational_operator shift_expression relational_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: relational_operator, null
      _failure(_expect28);
    }
    // <= relational_operator shift_expression relational_expression1 / '' # Choice
    if (_cacheable[44]) {
      _addToCache($$, pos, 44);
    }  
    return $$;
  }
  
  dynamic _parse_relational_operator() {
    // LEXEME
    // relational_operator <- LT / GT / LTE / GTE
    var $$;
    // => LT / GT / LTE / GTE # Choice
    switch (_getState(_transitions35)) {
      // [<]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => LT
          $$ = _parse_LT();
          // <= LT
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => LTE
          $$ = _parse_LTE();
          // <= LTE
          _startPos = startPos1;
          break;
        }
        break;
      // [>]
      case 1:
        while (true) {
          var startPos2 = _startPos;
          // => GT
          $$ = _parse_GT();
          // <= GT
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          // => GTE
          $$ = _parse_GTE();
          // <= GTE
          _startPos = startPos3;
          break;
        }
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: relational_operator
      _failure(_expect73);
    }
    // <= LT / GT / LTE / GTE # Choice
    return $$;
  }
  
  dynamic _parse_replacement_list() {
    // MORPHEME
    // replacement_list <- pp_tokens?
    var $$;
    _beginToken(18);  
    // => pp_tokens? # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => pp_tokens?
        var testing0 = _testing;
        _testing = _cursor;
        // => pp_tokens
        $$ = _parse_pp_tokens();
        // <= pp_tokens
        success = true; 
        _testing = testing0;
        // <= pp_tokens?
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: replacement_list
      _failure(_expect38);
    }
    // <= pp_tokens? # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_rparen() {
    // LEXEME
    // rparen <- ')' spaces
    var $$;
    // => ')' spaces # Choice
    switch (_ch == 41 ? 0 : _ch == -1 ? 2 : 1) {
      // [)]
      case 0:
        // => ')' spaces # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => ')'
          $$ = ')';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= ')'
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => spaces
          $$ = _parse_spaces();
          // <= spaces
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= ')' spaces # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: ')'
      _failure(_expect74);
    }
    // <= ')' spaces # Choice
    return $$;
  }
  
  dynamic _parse_s_char() {
    // MORPHEME
    // s_char <- (![\n\r"\\] .) / escape_sequence
    var $$;
    _beginToken(17);  
    // => (![\n\r"\\] .) / escape_sequence # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => (![\n\r"\\] .) # Choice
          switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
            // [\u0000-\u0010ffff]
            // EOF
            case 0:
            case 2:
              // => ![\n\r"\\] . # Sequence
              var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                // => ![\n\r"\\]
                var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
                _testing = _inputLen + 1;
                // => [\n\r"\\]
                $$ = _matchMapping(10, 92, _mapping1);
                // <= [\n\r"\\]
                _ch = ch1;
                _cursor = pos1; 
                _testing = testing0;
                $$ = null;
                success = !success;
                // <= ![\n\r"\\]
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                // => .
                $$ = _matchAny();
                // <= .
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                break;
              }
              if (!success) {
                _ch = ch0;
                _cursor = pos0;
              }
              _startPos = startPos1;
              // <= ![\n\r"\\] . # Sequence
              break;
            // No matches
            case 1:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            // Expected: null
            _failure(_expect17);
          }
          // <= (![\n\r"\\] .) # Choice
          _startPos = startPos0;
          if (success) break;
          var startPos2 = _startPos;
          // => escape_sequence
          $$ = _parse_escape_sequence();
          // <= escape_sequence
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
      // EOF
      case 2:
        var startPos3 = _startPos;
        // => (![\n\r"\\] .) # Choice
        switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
          // [\u0000-\u0010ffff]
          // EOF
          case 0:
          case 2:
            // => ![\n\r"\\] . # Sequence
            var ch2 = _ch, pos2 = _cursor, startPos4 = _startPos;
            _startPos = _cursor;
            while (true) {  
              // => ![\n\r"\\]
              var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
              _testing = _inputLen + 1;
              // => [\n\r"\\]
              $$ = _matchMapping(10, 92, _mapping1);
              // <= [\n\r"\\]
              _ch = ch3;
              _cursor = pos3; 
              _testing = testing1;
              $$ = null;
              success = !success;
              // <= ![\n\r"\\]
              if (!success) break;
              var seq = new List(2)..[0] = $$;
              // => .
              $$ = _matchAny();
              // <= .
              if (!success) break;
              seq[1] = $$;
              $$ = seq;
              break;
            }
            if (!success) {
              _ch = ch2;
              _cursor = pos2;
            }
            _startPos = startPos4;
            // <= ![\n\r"\\] . # Sequence
            break;
          // No matches
          case 1:
            $$ = null;
            success = false;
            break;
        }
        if (!success && _cursor > _testing) {
          // Expected: null
          _failure(_expect17);
        }
        // <= (![\n\r"\\] .) # Choice
        _startPos = startPos3;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: s_char
      _failure(_expect23);
    }
    // <= (![\n\r"\\] .) / escape_sequence # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_s_char_sequence() {
    // MORPHEME
    // s_char_sequence <- s_char+
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(36);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(16);    
    // => s_char+ # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        var startPos0 = _startPos;
        // => s_char+
        var testing0;
        for (var first = true, reps; ;) {  
          // => s_char  
          $$ = _parse_s_char();  
          // <= s_char  
          if (success) {
           if (first) {      
              first = false;
              reps = [$$];
              testing0 = _testing;                  
            } else {
              reps.add($$);
            }
            _testing = _cursor;   
          } else {
            success = !first;
            if (success) {      
              _testing = testing0;
              $$ = reps;      
            } else $$ = null;
            break;
          }  
        }
        // <= s_char+
        _startPos = startPos0;
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: s_char_sequence
      _failure(_expect22);
    }
    // <= s_char+ # Choice
    if (_cacheable[36]) {
      _addToCache($$, pos, 36);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_shift_expression() {
    // NONTERMINAL
    // shift_expression <- additive_expression shift_expression1
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(14);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => additive_expression shift_expression1 # Choice
    switch (_getState(_transitions0)) {
      // [!-\"] [&-(] [*-+] [--.] [0-9] [A-Z] [\\] [a-z] [~]
      case 0:
        // => additive_expression shift_expression1 # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => additive_expression
          $$ = _parse_additive_expression();
          // <= additive_expression
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => shift_expression1
          $$ = _parse_shift_expression1();
          // <= shift_expression1
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= additive_expression shift_expression1 # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= additive_expression shift_expression1 # Choice
    if (_cacheable[14]) {
      _addToCache($$, pos, 14);
    }  
    return $$;
  }
  
  dynamic _parse_shift_expression1() {
    // NONTERMINAL
    // shift_expression1 <- shift_operator additive_expression shift_expression1 / ''
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(43);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => shift_operator additive_expression shift_expression1 / '' # Choice
    switch (_getState(_transitions16)) {
      // [\u0000-;] [=-\u0010ffff]
      // EOF
      case 0:
      case 3:
        var startPos0 = _startPos;
        // => ''
        success = true;
        $$ = '';
        // <= ''
        _startPos = startPos0;
        break;
      // [<]
      case 1:
        while (true) {
          // => shift_operator additive_expression shift_expression1 # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => shift_operator
            $$ = _parse_shift_operator();
            // <= shift_operator
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => additive_expression
            $$ = _parse_additive_expression();
            // <= additive_expression
            if (!success) break;
            seq[1] = $$;
            // => shift_expression1
            $$ = _parse_shift_expression1();
            // <= shift_expression1
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          // <= shift_operator additive_expression shift_expression1 # Sequence
          if (success) break;
          var startPos2 = _startPos;
          // => ''
          success = true;
          $$ = '';
          // <= ''
          _startPos = startPos2;
          break;
        }
        break;
      // No matches
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<<', null
      _failure(_expect27);
    }
    // <= shift_operator additive_expression shift_expression1 / '' # Choice
    if (_cacheable[43]) {
      _addToCache($$, pos, 43);
    }  
    return $$;
  }
  
  dynamic _parse_shift_operator() {
    // LEXEME
    // shift_operator <- LSH / RSH
    var $$;
    // => LSH / RSH # Choice
    switch (_ch == 60 ? 0 : _ch == -1 ? 2 : 1) {
      // [<]
      case 0:
        while (true) {
          var startPos0 = _startPos;
          // => LSH
          $$ = _parse_LSH();
          // <= LSH
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          // => RSH
          $$ = _parse_RSH();
          // <= RSH
          _startPos = startPos1;
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '<<'
      _failure(_expect75);
    }
    // <= LSH / RSH # Choice
    return $$;
  }
  
  dynamic _parse_sign() {
    // MORPHEME
    // sign <- [+\-]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(93);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(36);    
    // => [+\-] # Choice
    switch (_getState(_transitions36)) {
      // [+] [-]
      case 0:
        var startPos0 = _startPos;
        // => [+\-]
        $$ = _matchMapping(43, 45, _mapping5);
        // <= [+\-]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: sign
      _failure(_expect76);
    }
    // <= [+\-] # Choice
    if (_cacheable[93]) {
      _addToCache($$, pos, 93);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_simple_escape_sequence() {
    // MORPHEME
    // simple_escape_sequence <- ["'?\\a-bfnrtv]
    var $$;
    _beginToken(37);  
    // => ["'?\\a-bfnrtv] # Choice
    switch (_getState(_transitions37)) {
      // [\"] [\'] [?] [\\] [a-b] [f] [n] [r] [t] [v]
      case 0:
        var startPos0 = _startPos;
        // => ["'?\\a-bfnrtv]
        $$ = _matchMapping(34, 118, _mapping6);
        // <= ["'?\\a-bfnrtv]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: simple_escape_sequence
      _failure(_expect77);
    }
    // <= ["'?\\a-bfnrtv] # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_spaces() {
    // LEXEME & MORPHEME
    // spaces <- [\t-\n\r ]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(125);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(66);    
    // => [\t-\n\r ] # Choice
    switch (_getState(_transitions47)) {
      // [\t-\n] [\r] [ ]
      case 0:
        var startPos0 = _startPos;
        // => [\t-\n\r ]
        $$ = _matchMapping(9, 32, _mapping10);
        // <= [\t-\n\r ]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: spaces
      _failure(_expect102);
    }
    // <= [\t-\n\r ] # Choice
    if (_cacheable[125]) {
      _addToCache($$, pos, 125);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_string_literal() {
    // LEXEME & MORPHEME
    // string_literal <- '"' s_char_sequence? '"' / 'L"' s_char_sequence? '"'
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(35);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(15);    
    // => '"' s_char_sequence? '"' / 'L"' s_char_sequence? '"' # Choice
    switch (_getState(_transitions12)) {
      // [\"]
      case 0:
        // => '"' s_char_sequence? '"' # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '"'
          $$ = '\"';
          success = true;
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
            _ch = -1;
          }
          // <= '"'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => s_char_sequence?
          var testing0 = _testing;
          _testing = _cursor;
          // => s_char_sequence
          $$ = _parse_s_char_sequence();
          // <= s_char_sequence
          success = true; 
          _testing = testing0;
          // <= s_char_sequence?
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '"' s_char_sequence? '"' # Sequence
        break;
      // [L]
      case 1:
        // => 'L"' s_char_sequence? '"' # Sequence
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => 'L"'
          $$ = _matchString(_strings5, 'L\"');
          // <= 'L"'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => s_char_sequence?
          var testing1 = _testing;
          _testing = _cursor;
          // => s_char_sequence
          $$ = _parse_s_char_sequence();
          // <= s_char_sequence
          success = true; 
          _testing = testing1;
          // <= s_char_sequence?
          if (!success) break;
          seq[1] = $$;
          // => '"'
          $$ = _matchChar(34, '\"');
          // <= '"'
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        // <= 'L"' s_char_sequence? '"' # Sequence
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: string_literal
      _failure(_expect21);
    }
    // <= '"' s_char_sequence? '"' / 'L"' s_char_sequence? '"' # Choice
    if (_cacheable[35]) {
      _addToCache($$, pos, 35);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_text_line() {
    // LEXEME
    // text_line <- pp_tokens? new_line
    var $$;
    // => pp_tokens? new_line # Choice
    switch (_getState(_transitions26)) {
      // [\n] [\r] [!-?] [A-]] [a-{] [}-~]
      case 0:
        // => pp_tokens? new_line # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => pp_tokens?
          var testing0 = _testing;
          _testing = _cursor;
          // => pp_tokens
          $$ = _parse_pp_tokens();
          // <= pp_tokens
          success = true; 
          _testing = testing0;
          // <= pp_tokens?
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= pp_tokens? new_line # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: text_line
      _failure(_expect45);
    }
    // <= pp_tokens? new_line # Choice
    return $$;
  }
  
  dynamic _parse_unary_expression() {
    // NONTERMINAL
    // unary_expression <- primary_expression / unary_operator unary_expression
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(17);
    }
    if($$ != null) {
      return $$[0];       
    }  
    // => primary_expression / unary_operator unary_expression # Choice
    switch (_getState(_transitions1)) {
      // [!] [&] [*-+] [~]
      case 0:
        // => unary_operator unary_expression # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => unary_operator
          $$ = _parse_unary_operator();
          // <= unary_operator
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => unary_expression
          $$ = _parse_unary_expression();
          // <= unary_expression
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= unary_operator unary_expression # Sequence
        break;
      // [\"] [\'-(] [--.] [0-9] [A-Z] [\\] [a-z]
      case 1:
        var startPos1 = _startPos;
        // => primary_expression
        $$ = _parse_primary_expression();
        // <= primary_expression
        _startPos = startPos1;
        break;
      // No matches
      // EOF
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: identifier, constant, string_literal, '(', unary_operator
      _failure(_expect2);
    }
    // <= primary_expression / unary_operator unary_expression # Choice
    if (_cacheable[17]) {
      _addToCache($$, pos, 17);
    }  
    return $$;
  }
  
  dynamic _parse_unary_operator() {
    // LEXEME
    // unary_operator <- AMPERSAND / ASTERISK / PLUS / MINUS / TILDE / EXCLAMATION
    var $$;
    // => AMPERSAND / ASTERISK / PLUS / MINUS / TILDE / EXCLAMATION # Choice
    switch (_getState(_transitions38)) {
      // [!]
      case 0:
        var startPos0 = _startPos;
        // => EXCLAMATION
        $$ = _parse_EXCLAMATION();
        // <= EXCLAMATION
        _startPos = startPos0;
        break;
      // [&]
      case 1:
        var startPos1 = _startPos;
        // => AMPERSAND
        $$ = _parse_AMPERSAND();
        // <= AMPERSAND
        _startPos = startPos1;
        break;
      // [*]
      case 2:
        var startPos2 = _startPos;
        // => ASTERISK
        $$ = _parse_ASTERISK();
        // <= ASTERISK
        _startPos = startPos2;
        break;
      // [+]
      case 3:
        while (true) {
          var startPos3 = _startPos;
          // => PLUS
          $$ = _parse_PLUS();
          // <= PLUS
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          // => MINUS
          $$ = _parse_MINUS();
          // <= MINUS
          _startPos = startPos4;
          break;
        }
        break;
      // [~]
      case 4:
        var startPos5 = _startPos;
        // => TILDE
        $$ = _parse_TILDE();
        // <= TILDE
        _startPos = startPos5;
        break;
      // No matches
      // EOF
      case 5:
      case 6:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: unary_operator
      _failure(_expect78);
    }
    // <= AMPERSAND / ASTERISK / PLUS / MINUS / TILDE / EXCLAMATION # Choice
    return $$;
  }
  
  dynamic _parse_undef() {
    // MORPHEME
    // undef <- '#undef' identifier new_line
    var $$;
    _beginToken(23);  
    // => '#undef' identifier new_line # Choice
    switch (_ch == 35 ? 0 : _ch == -1 ? 2 : 1) {
      // [#]
      case 0:
        // => '#undef' identifier new_line # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => '#undef'
          $$ = _matchString(_strings9, '#undef');
          // <= '#undef'
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          // => identifier
          $$ = _parse_identifier();
          // <= identifier
          if (!success) break;
          seq[1] = $$;
          // => new_line
          $$ = _parse_new_line();
          // <= new_line
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= '#undef' identifier new_line # Sequence
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: '#undef'
      _failure(_expect43);
    }
    // <= '#undef' identifier new_line # Choice
    _endToken();
    return $$;
  }
  
  dynamic _parse_universal_character_name() {
    // MORPHEME
    // universal_character_name <- '\\u' hex_quad / '\\U' hex_quad hex_quad
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(96);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(38);    
    // => '\\u' hex_quad / '\\U' hex_quad hex_quad # Choice
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      // [\\]
      case 0:
        while (true) {
          // => '\\u' hex_quad # Sequence
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\u'
            $$ = _matchString(_strings29, '\\u');
            // <= '\\u'
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            // => hex_quad
            $$ = _parse_hex_quad();
            // <= hex_quad
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          // <= '\\u' hex_quad # Sequence
          if (success) break;
          // => '\\U' hex_quad hex_quad # Sequence
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            // => '\\U'
            $$ = _matchString(_strings30, '\\U');
            // <= '\\U'
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            // => hex_quad
            $$ = _parse_hex_quad();
            // <= hex_quad
            if (!success) break;
            seq[1] = $$;
            // => hex_quad
            $$ = _parse_hex_quad();
            // <= hex_quad
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          // <= '\\U' hex_quad hex_quad # Sequence
          break;
        }
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: universal_character_name
      _failure(_expect79);
    }
    // <= '\\u' hex_quad / '\\U' hex_quad hex_quad # Choice
    if (_cacheable[96]) {
      _addToCache($$, pos, 96);
    }  
    _endToken();
    return $$;
  }
  
  dynamic _parse_unsigned_suffix() {
    // MORPHEME
    // unsigned_suffix <- [Uu]
    var $$;          
    var pos = _cursor;    
    if(pos <= _cachePos) {
      $$ = _getFromCache(126);
    }
    if($$ != null) {
      return $$[0];       
    }  
    _beginToken(67);    
    // => [Uu] # Choice
    switch (_getState(_transitions48)) {
      // [U] [u]
      case 0:
        var startPos0 = _startPos;
        // => [Uu]
        $$ = _matchMapping(85, 117, _mapping11);
        // <= [Uu]
        _startPos = startPos0;
        break;
      // No matches
      // EOF
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: unsigned_suffix
      _failure(_expect103);
    }
    // <= [Uu] # Choice
    if (_cacheable[126]) {
      _addToCache($$, pos, 126);
    }  
    _endToken();
    return $$;
  }
  
  String _text() {
    return new String.fromCharCodes(_input.sublist(_startPos, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<PParserError> errors() {
    if (success) {
      return <PParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <PParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<PParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new PParserError(PParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new PParserError(PParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_preprocessing_file() {
    // NONTERMINAL
    // preprocessing_file <- group? EOF
    var $$;
    // => group? EOF # Choice
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      // [\u0000-\u0010ffff]
      // EOF
      case 0:
      case 2:
        // => group? EOF # Sequence
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          // => group?
          var testing0 = _testing;
          _testing = _cursor;
          // => group
          $$ = _parse_group();
          // <= group
          success = true; 
          _testing = testing0;
          // <= group?
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          // => EOF
          $$ = _parse_EOF();
          // <= EOF
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        // <= group? EOF # Sequence
        break;
      // No matches
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      // Expected: EOF
      _failure(_expect0);
    }
    // <= group? EOF # Choice
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List(_inputLen + 1);
    _cachePos = -1;
    _cacheRule = new List(_inputLen + 1);
    _cacheState = new List.filled(((_inputLen + 1) >> 5) + 1, 0);
    _cacheable = new List<bool>.filled(128, false);
    _ch = -1;
    _errors = <PParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenLevel = 0;
    _tokenStart = null;
    _trackPos = new List<int>.filled(128, 0);
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
}

class PParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  PParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is PParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

