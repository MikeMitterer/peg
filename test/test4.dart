// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

library json_parser;

void main() {
  var parser = new JsonParser('{}');
  print(parser.parse_jsonText());
}

class _KeyValuePair<K, V> {
  final K key;
  final V value;
  const _KeyValuePair(this.key, this.value);
  String toString() => "$key : $value";
}

String _hex2str(String hex) {
  return new String.fromCharCode(int.parse(hex, radix: 16));
}

// "\\/bfnrt
String _escape(String string) {
  switch (string) {
    case "\"":
      return "\u0022";
    case "\\":
      return "\u005c";
    case "/":
      return "\u002f";
    case "r":
      return "\u000d";
    case "n":
      return "\u000a";
    case "t":
      return "\u0009";
    case "b":
      return "\u0008";
    case "f":
      return "\u000c";
  }
  return string;
}
class JsonParser {
  static final List<String> _ascii =
      new List<String>.generate(128, (c) => new String.fromCharCode(c));

  final List<int> _tokenFlags = [
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1];

  final List<String> _tokenNames = [
      "QUOTATION_MARK",
      "\'[\'",
      "\'{\'",
      "\'.\'",
      "\']\'",
      "\'}\'",
      "EXP",
      "\'false\'",
      "\'.\'",
      "INT",
      "\':\'",
      "\'null\'",
      "NUMBER",
      "NUMBER_PART",
      "STRING",
      "STRING_CHARS",
      "\'true\'",
      "\',\'",
      "CHAR",
      "CHAR_HEXDIG",
      "DIGIT",
      "\'\\\'",
      "EOF",
      "HEXDIG",
      "UNESCAPED",
      "WS"];

  List _cache;

  int _cachePos;

  List<int> _cacheRule;

  List<int> _cacheState;

  int _ch;

  List<int> _code = [
      9,
      268,
      13,
      266,
      8,
      6,
      9,
      7,
      15,
      10,
      3,
      0,
      9,
      258,
      9,
      15,
      13,
      13,
      5,
      11,
      12,
      6,
      9,
      23,
      13,
      21,
      5,
      19,
      12,
      6,
      9,
      31,
      13,
      29,
      5,
      27,
      12,
      6,
      9,
      166,
      13,
      164,
      9,
      39,
      13,
      37,
      2,
      35,
      8,
      50,
      9,
      152,
      13,
      150,
      9,
      132,
      13,
      130,
      9,
      118,
      13,
      116,
      3,
      43,
      9,
      112,
      14,
      110,
      15,
      70,
      9,
      106,
      9,
      58,
      3,
      46,
      3,
      49,
      3,
      52,
      3,
      55,
      13,
      81,
      2,
      62,
      3,
      64,
      13,
      104,
      2,
      83,
      12,
      94,
      9,
      100,
      13,
      98,
      9,
      94,
      3,
      85,
      3,
      88,
      3,
      91,
      12,
      98,
      12,
      6,
      9,
      126,
      13,
      124,
      2,
      122,
      12,
      12,
      15,
      120,
      9,
      146,
      13,
      144,
      9,
      140,
      13,
      138,
      2,
      136,
      12,
      132,
      9,
      160,
      13,
      158,
      2,
      156,
      9,
      200,
      13,
      198,
      9,
      174,
      13,
      172,
      2,
      170,
      8,
      150,
      9,
      186,
      13,
      184,
      15,
      156,
      9,
      180,
      13,
      178,
      12,
      162,
      9,
      194,
      13,
      192,
      2,
      190,
      9,
      254,
      13,
      252,
      9,
      248,
      13,
      246,
      8,
      178,
      2,
      204,
      9,
      206,
      7,
      100,
      8,
      186,
      9,
      220,
      13,
      218,
      9,
      214,
      13,
      212,
      2,
      210,
      12,
      6,
      7,
      100,
      8,
      202,
      9,
      242,
      13,
      240,
      9,
      228,
      2,
      224,
      2,
      226,
      8,
      214,
      9,
      236,
      2,
      232,
      2,
      234,
      7,
      100,
      12,
      6,
      12,
      226,
      9,
      262,
      6,
      230,
      1];

  int _cursor;

  List _data = [
      3,
      9,
      10,
      13,
      13,
      32,
      32,
      1,
      [8],
      [[0, 1114111, [8]]],
      [],
      [102, 97, 108, 115, 101],
      "false",
      2,
      [18, 20],
      0,
      [16],
      [[0, 1114111, [16]]],
      [],
      [110, 117, 108, 108],
      "null",
      2,
      [26, 28],
      0,
      [24],
      [[0, 1114111, [24]]],
      [],
      [116, 114, 117, 101],
      "true",
      2,
      [34, 36],
      0,
      [32],
      [[0, 1114111, [32]]],
      [],
      123,
      "{",
      0,
      [46, 6],
      0,
      [44],
      [[0, 1114111, [44]]],
      [],
      1,
      34,
      34,
      1,
      32,
      33,
      1,
      35,
      91,
      1,
      93,
      126,
      1,
      93,
      1114111,
      0,
      [74, 76, 78, 80],
      [[0, 1114111, [74, 76, 78, 80]]],
      [],
      92,
      "\\",
      8,
      34,
      34,
      47,
      47,
      92,
      92,
      98,
      98,
      102,
      102,
      110,
      110,
      114,
      114,
      116,
      116,
      2,
      [84, 86],
      117,
      "u",
      1,
      48,
      57,
      1,
      97,
      102,
      1,
      65,
      70,
      0,
      [100, 102, 104],
      [[0, 1114111, [100, 102, 104]]],
      [],
      8,
      [98, 98, 98, 106],
      0,
      [96],
      [[0, 1114111, [96]]],
      [],
      4,
      [84, 90, 92],
      0,
      [72, 82, 88],
      [[0, 1114111, [72, 82, 88]]],
      [],
      1,
      68,
      1,
      [66],
      [[0, 1114111, [66]]],
      [],
      8,
      [62, 64, 62, 108],
      0,
      [60],
      [[0, 1114111, [60]]],
      [],
      58,
      ":",
      0,
      [114, 6],
      0,
      [112],
      [[0, 1114111, [112]]],
      [],
      4,
      [58, 110, 116],
      0,
      [56],
      [[0, 1114111, [56]]],
      [],
      44,
      ",",
      0,
      [128, 6],
      0,
      [126],
      [[0, 1114111, [126]]],
      [],
      0,
      [124, 54],
      0,
      [122],
      [[0, 1114111, [122]]],
      [],
      2,
      [54, 118],
      0,
      [52],
      [[0, 1114111, [52]]],
      [],
      125,
      "}",
      0,
      [136, 6],
      0,
      [134],
      [[0, 1114111, [134]]],
      [],
      4,
      [42, 48, 130],
      0,
      [40],
      [[0, 1114111, [40]]],
      [],
      91,
      "[",
      0,
      [146, 6],
      0,
      [144],
      [[0, 1114111, [144]]],
      [],
      0,
      [124, 12],
      0,
      [158],
      [[0, 1114111, [158]]],
      [],
      2,
      [12, 154],
      0,
      [152],
      [[0, 1114111, [152]]],
      [],
      93,
      "]",
      0,
      [166, 6],
      0,
      [164],
      [[0, 1114111, [164]]],
      [],
      4,
      [142, 148, 160],
      0,
      [140],
      [[0, 1114111, [140]]],
      [],
      45,
      "-",
      0,
      [182],
      [[0, 1114111, [182]]],
      [],
      46,
      ".",
      2,
      [194, 196],
      0,
      [192],
      [[0, 1114111, [192]]],
      [],
      0,
      [190, 198],
      0,
      [188],
      [[0, 1114111, [188]]],
      [],
      101,
      "e",
      69,
      "E",
      0,
      [208, 210],
      [[0, 1114111, [208, 210]]],
      [],
      45,
      "-",
      43,
      "+",
      0,
      [216, 218],
      [[0, 1114111, [216, 218]]],
      [],
      0,
      [206, 212, 220],
      0,
      [204],
      [[0, 1114111, [204]]],
      [],
      8,
      [176, 180, 184, 200],
      0,
      [174],
      [[0, 1114111, [174]]],
      [],
      2,
      [172, 222],
      0,
      [170],
      [[0, 1114111, [170]]],
      [],
      0,
      [14, 22, 30, 38, 138, 168, 58],
      [[0, 1114111, [14, 22, 30, 38, 138, 168, 58]]],
      [],
      0,
      [228],
      [[0, 1114111, [228]]],
      [],
      4,
      [4, 12, 224],
      0,
      [2],
      [[0, 1114111, [2]]],
      []];

  List<JsonParserError> _errors;

  List<String> _expected;

  int _failurePos;

  List<int> _input;

  int _inputLen;

  Object _result;

  int _startPos;

  int _testing;

  int _token;

  int _tokenLevel;

  int _tokenStart;

  bool success;

  final String text;

  JsonParser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }
    _input = _toCodePoints(text);
    _inputLen = _input.length;
    if (_inputLen >= 0x3fffffe8 / 32) {
      throw new StateError('File size to big: $_inputLen');
    }
    reset(0);
  }

  dynamic _action(int cp, v) {
    var $$ = _result;
    if (cp < 116) {
      if (cp < 86) {
        if (cp < 36) {
          if (cp == 28) {
            final $1 = v[0],
                $2 = v[1];
            $$ = null;
            return $$;
          } else if (cp == 20) {
            final $1 = v[0],
                $2 = v[1];
            $$ = false;
            return $$;
          }
        } else if (cp == 36) {
          final $1 = v[0],
              $2 = v[1];
          $$ = true;
          return $$;
        } else if (cp == 68) {
          final $1 = v;
          $$ = $1.join();
          return $$;
        }
      } else if (cp < 106) {
        if (cp == 92) {
          final $1 = v[0],
              $2 = v[1],
              $3 = v[2];
          $$ = _hex2str($3);
          return $$;
        } else if (cp == 86) {
          final $1 = v[0],
              $2 = v[1];
          $$ = _escape($2);
          return $$;
        }
      } else if (cp == 106) {
        final $1 = v[0],
            $2 = v[1],
            $3 = v[2],
            $4 = v[3];
        $$ = _text();
        return $$;
      } else if (cp == 108) {
        final $1 = v[0],
            $2 = v[1],
            $3 = v[2],
            $4 = v[3];
        $$ = $2;
        return $$;
      }
    } else if (cp < 160) {
      if (cp < 130) {
        if (cp == 118) {
          final $1 = v[0],
              $2 = v[1];
          $$ = _list($1, $2);
          return $$;
        } else if (cp == 116) {
          final $1 = v[0],
              $2 = v[1],
              $3 = v[2];
          $$ = new _KeyValuePair($1, $3);
          return $$;
        }
      } else if (cp == 130) {
        final $1 = v[0],
            $2 = v[1],
            $3 = v[2];
        $$ = $2.fold({}, (p, c) => p..[c.key] = c.value);
        return $$;
      } else if (cp == 154) {
        final $1 = v[0],
            $2 = v[1];
        $$ = _list($1, $2);
        return $$;
      }
    } else if (cp < 200) {
      if (cp == 196) {
        final $1 = v[0],
            $2 = v[1];
        $$ = $1;
        return $$;
      } else if (cp == 160) {
        final $1 = v[0],
            $2 = v[1],
            $3 = v[2];
        $$ = $2;
        return $$;
      }
    } else if (cp < 222) {
      if (cp == 200) {
        final $1 = v[0],
            $2 = v[1],
            $3 = v[2],
            $4 = v[3];
        $$ = double.parse(_text());
        return $$;
      }
    } else if (cp == 222) {
      final $1 = v[0],
          $2 = v[1];
      $$ = $1;
      return $$;
    } else if (cp == 224) {
      final $1 = v[0],
          $2 = v[1],
          $3 = v[2];
      $$ = $2;
      return $$;
    }
    throw new StateError(
        "Instruction at address '$cp' nas no semantic action.");
  }

  void _andPredicate(int cp) {
    var ch = _ch;
    var cursor = _cursor;
    var testing = _testing;
    _testing = _inputLen + 1;
    _decode(_code[cp + 1]);
    _result = null;
    _testing = testing;
    _cursor = cursor;
    _ch = ch;
  }

  void _anyCharacter(int cp) {
    success = _cursor < _inputLen;
    if (success) {
      if (_ch < 128) {
        _result = _ascii[_ch];
      } else {
        _result = new String.fromCharCode(_ch);
      }
      _cursor++;
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }
    } else {
      _result = null;
    }
  }

  void _character(int cp) {
    var offset = _code[cp + 1];
    _result = _data[offset + 1];
    success = _cursor < _inputLen;
    if (success && _ch == _data[offset + 0]) {
      _cursor++;
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }
    } else {
      success = false;
    }
  }

  void _characterClass(int cp) {
    var offset = _code[cp + 1];
    success = _cursor < _inputLen;
    if (success) {
      int length = _data[offset + 0];
      int ranges = offset + 1;
      for (var i = 0; i < length; i++, ranges += 2) {
        if (_ch >= _data[ranges + 0]) {
          if (_ch <= _data[ranges + 1]) {
            if (_ch < 128) {
              _result = _ascii[_ch];
            } else {
              _result = new String.fromCharCode(_ch);
            }
            _cursor++;
            if (_cursor < _inputLen) {
              _ch = _input[_cursor];
            } else {
              _ch = -1;
            }
            return;
          }
        } else {
          break;
        }
      }
      success = false;
    }
    _result = null;
  }

  void _decode(int cp) {
    var op = _code[cp];
    if (op < 7) {
      if (op < 3) {
        if (op == 0) {
          return _andPredicate(cp);
        } else if (op == 1) {
          return _anyCharacter(cp);
        } else if (op == 2) {
          return _character(cp);
        }
      } else if (op < 5) {
        if (op == 4) {
          return _empty(cp);
        } else if (op == 3) {
          return _characterClass(cp);
        }
      } else if (op == 5) {
        return _literal(cp);
      } else if (op == 6) {
        return _notPredicate(cp);
      }
    } else if (op < 12) {
      if (op < 9) {
        if (op == 8) {
          return _optional(cp);
        } else if (op == 7) {
          return _oneOrMore(cp);
        }
      } else if (op == 9) {
        return _orderedChoice(cp);
      } else if (op == 11) {
        return _productionRule(cp);
      }
    } else if (op < 14) {
      if (op == 13) {
        return _sequence(cp);
      } else if (op == 12) {
        return _rule(cp);
      }
    } else if (op == 14) {
      return _sequenceElement(cp);
    } else if (op == 15) {
      return _zeroOrMore(cp);
    }
    throw new StateError("Illegal instruction op");
  }

  void _empty(int cp) {
    _result = "";
    success = true;
  }

  void _failure([List<String> expected]) {
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {
      _expected = [];
      _failurePos = _cursor;
    }
    if (_token != null) {
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos == _inputLen && (flag & 1) != 0) {
        var message = "Unterminated $name";
        _errors.add(
            new JsonParserError(
                JsonParserError.UNTERMINATED,
                _failurePos,
                _tokenStart,
                message));
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {
        var message = "Malformed $name";
        _errors.add(
            new JsonParserError(
                JsonParserError.MALFORMED,
                _failurePos,
                _tokenStart,
                message));
      }
      _expected.add(name);
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }
  }

  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }

  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }

  void _literal(int cp) {
    var offset = _code[cp + 1];
    List<int> characters = _data[offset + 0];
    var length = characters.length;
    _result = _data[offset + 1];
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (characters[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
      if (success) {
        _cursor += length;
        if (_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }
        return;
      }
    }
  }

  void _notPredicate(int cp) {
    var ch = _ch;
    var cursor = _cursor;
    var testing = _testing;
    _testing = _inputLen + 1;
    _decode(_code[cp + 1]);
    _result = null;
    _testing = testing;
    _cursor = cursor;
    _ch = ch;
    success = !success;
  }

  void _oneOrMore(int cp) {
    cp = _code[cp + 1];
    _decode(cp);
    if (!success) {
      return;
    }
    var elements = [_result];
    var testing = _testing;
    while (true) {
      _testing = _inputLen + 1;
      _decode(cp);
      if (!success) {
        break;
      }
      elements.add(_result);
    }
    _testing = testing;
    _result = elements;
    success = true;
  }

  void _optional(int cp) {
    _decode(_code[cp + 1]);
    success = true;
  }

  void _orderedChoice(int cp) {
    var offset = _code[cp + 1];
    List transitions = _data[offset + 2];
    List<int> instructions;
    for (var i = 0; i < transitions.length; i++) {
      List transition = transitions[i];
      if (_ch >= transition[0]) {
        if (_ch <= transition[1]) {
          instructions = transition[2];
          break;
        }
      } else {
        break;
      }
    }
    if (instructions == null) {
      if (_ch == -1) {
        instructions = _data[offset + 1];
      } else if (_data[offset + 3].length != 0) {
        instructions = _data[offset + 3];
      } else {
        _result = null;
        success = _data[offset + 0] & 1 != 0;
        return;
      }
    }
    var index = 0;
    var count = instructions.length - 1;
    while (true) {
      _decode(instructions[index++]);
      if (success) {
        break;
      } else if (count-- == 0) {
        _result = null;
        success = false;
        break;
      }
    }
  }

  dynamic _parse(int cp) {
    _decode(cp);
    return _result;
  }

  void _productionRule(int cp) {
    // TODO: Memoization goes here
    // TODO: If memoized expectation errors goes here
    var offset = _code[cp + 1];
    _decode(_data[offset + 0]);
    // TODO: Memoization goes here
  }

  void _rule(int cp) {
    _decode(_code[cp + 1]);
  }

  void _sequence(int cp) {
    var index = 0;
    var ch = _ch;
    var cursor = _cursor;
    var offset = _code[cp + 1];
    List<int> instructions = _data[offset + 1];
    var count = instructions.length;
    cp = instructions[index++];
    _decode(cp);
    if (!success) {
      return;
    }
    var result = new List(count--);
    result[0] = _result;
    var flag = _data[offset + 0];
    if (flag & 1 != 0) {
      if (count == 0) {
        result = _action(cp, result);
      } else {
        result[0] = _action(cp, result);
      }
    }
    flag >>= 1;
    for ( ; count-- > 0; flag >>= 1, index++) {
      cp = instructions[index];
      _decode(cp);
      if (!success) {
        _ch = ch;
        _cursor = cursor;
        return;
      }
      result[index] = _result;
      if (flag & 1 != 0) {
        if (count == 0) {
          result = _action(cp, result);
        } else {
          result[index] = _action(cp, result);
        }
      }
    }
    _result = result;
  }

  void _sequenceElement(int cp) {
    var offset = _code[cp + 1];
    cp = _data[offset + 1];
    _decode(cp);
    if (!success) {
      return;
    }
    if (_data[offset + 0] & 1 != 0) {
      _result = _action(cp, _result);
    }
  }

  String _text() {
    return new String.fromCharCodes(_input.sublist(_startPos, _cursor));
  }

  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }

    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }

    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }

    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }

    return start;
  }

  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }

    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }

    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }

    codePoints.length = pos;
    return codePoints;
  }

  void _zeroOrMore(int cp) {
    cp = _code[cp + 1];
    var testing = _testing;
    _testing = _inputLen + 1;
    _decode(cp);
    if (!success) {
      _result = const [];
      _testing = testing;
      success = true;
      return;
    }
    var elements = [_result];
    while (true) {
      _testing = _inputLen + 1;
      _decode(cp);
      if (!success) {
        break;
      }
      elements.add(_result);
    }
    _testing = testing;
    _result = elements;
    success = true;
  }

  List<JsonParserError> errors() {
    if (success) {
      return <JsonParserError>[];
    }

    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    }

    String getc(int position) {
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";
      }
      return "end of file";
    }

    var errors = <JsonParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<JsonParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new JsonParserError(
            JsonParserError.UNEXPECTED,
            _failurePos,
            _failurePos,
            message);
        errors.add(error);
      } else {
        var found = getc(_failurePos);
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new JsonParserError(
            JsonParserError.EXPECTED,
            _failurePos,
            _failurePos,
            message);
        errors.add(error);
      }
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;
  }

  dynamic parse_jsonText() => _parse(0);

  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }
    _cursor = pos;
    _cache = new List(_inputLen + 1);
    _cachePos = -1;
    _cacheRule = new List(_inputLen + 1);
    _cacheState = new List.filled(((_inputLen + 1) >> 5) + 1, 0);
    _ch = -1;
    _errors = <JsonParserError>[];
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;
    _testing = -1;
    _token = null;
    _tokenLevel = 0;
    _tokenStart = null;
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;
  }

}

class JsonParserError {
  static const int EXPECTED = 1;

  static const int MALFORMED = 2;

  static const int MISSING = 3;

  static const int UNEXPECTED = 4;

  static const int UNTERMINATED = 5;

  final int hashCode = 0;

  final String message;

  final int position;

  final int start;

  final int type;

  JsonParserError(this.type, this.position, this.start, this.message);

  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is JsonParserError) {
      return type == other.type &&
          position == other.position &&
          start == other.start &&
          message == other.message;
    }
    return false;
  }

}

